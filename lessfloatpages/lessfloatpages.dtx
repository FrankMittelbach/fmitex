% \iffalse meta-comment
%
%% File: lessfloatpages.dtx (C) Copyright 2019 Frank Mittelbach
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% The development version of the bundle can be found below
%
%    https://github.com/FrankMittelbach/fmitex/
%
% for those people who are interested or want to report an issue.
%

\def\lessfloatpagesdate   {2019/08/03}
\def\lessfloatpagesversion{prerelease}     %{v1.0a}


%<*driver>
\documentclass
    [final]
    {l3doc-TUB}

\makeatletter
  \@mparswitchfalse
\makeatother
    
\setcounter{page}{1}       

\newcommand\ctr[1]{\texttt{\upshape#1}}
\newcommand\option[1]{\texttt{\upshape#1}}
\newcommand\mnote[1]{\marginpar{\raggedleft\em #1}}

\usepackage{csquotes}
\EnableCrossrefs
\CodelineIndex


\begin{document}
 \DocInput{lessfloatpages.dtx}
\addtolength\signaturewidth{42pt}
\makesignature
\end{document}
%</driver>
%
% \fi
%
%
% \title{The \texttt{lessfloatpages} package\thanks{The current
%   package version is \texttt{\lessfloatpagesversion} dated
%   \lessfloatpagesdate.}}
% \author{Frank Mittelbach}
% \address{Mainz, Germany}
% \netaddress{https://www.latex-project.org}
% \personalURL{https://ctan.org/pkg/lessfloatpages}
%
% \maketitle
%
%
% \begin{abstract}
%
%   \LaTeX{}'s float algorithm has the tendency to produce fairly
%   empty float pages, i.e., pages containing only floats but with a
%   lot of free space remaining to could easily be filled with nearby
%   text. There are good reasons for this behavior\Dash nevertheless the
%   results look unappealing and in many cases documents are
%   unnecessarily enlarged.
%
%   The \pkg{lessfloatpages} package provides an extended algorithm
%   that improves on this without the need for manual interventions by
%   the user.
%
% \end{abstract}
%
% \tableofcontents
%
% \DoNotIndex{\@fpmin}
% \DoNotIndex{\@testwrongwidth}
% \DoNotIndex{\@cons}
% \DoNotIndex{\@currbox}
% \DoNotIndex{\@currtype}
% \DoNotIndex{\@elt}
% \DoNotIndex{\@empty}
% \DoNotIndex{\@gobble}
% \DoNotIndex{\@ne}
% \DoNotIndex{\@next}
% \DoNotIndex{\@spaces}
% \DoNotIndex{\@tempcnta}
% \DoNotIndex{\@tempcntb}
% \DoNotIndex{\@tempdima}
% \DoNotIndex{\@tempdimb}
% \DoNotIndex{\@testtrue}
% \DoNotIndex{\@undefined}
% \DoNotIndex{\@vtryfc}
% \DoNotIndex{\@xxxii}
% \DoNotIndex{\@ztryfc}
% \DoNotIndex{\fl@trace}
% \DoNotIndex{\@bitor}
% \DoNotIndex{\NeedsTeXFormat}
% \DoNotIndex{\TeX}
% \DoNotIndex{\advance}
% \DoNotIndex{\begingroup}
% \DoNotIndex{\bx@B}
% \DoNotIndex{\bx@D}
% \DoNotIndex{\bx@I}
% \DoNotIndex{\count}
% \DoNotIndex{\def}
% \DoNotIndex{\divide}
% \DoNotIndex{\else}
% \DoNotIndex{\endgroup}
% \DoNotIndex{\fi}
% \DoNotIndex{\gdef}
% \DoNotIndex{\global}
% \DoNotIndex{\ht}
% \DoNotIndex{\if@test}
% \DoNotIndex{\if@twocolumn}
% \DoNotIndex{\ifdim}
% \DoNotIndex{\ifnum}
% \DoNotIndex{\ifodd}
% \DoNotIndex{\ifx}
% \DoNotIndex{\let}
% \DoNotIndex{\maxdimen}
% \DoNotIndex{\multiply}
% \DoNotIndex{\newcommand}
% \DoNotIndex{\newcount}
% \DoNotIndex{\newcounter}
% \DoNotIndex{\providecommand}
% \DoNotIndex{\relax}
% \DoNotIndex{\renewcommand}
% \DoNotIndex{\reserved@a}
% \DoNotIndex{\sixt@@n}
% \DoNotIndex{\space}
% \DoNotIndex{\string}
% \DoNotIndex{\the}
% \DoNotIndex{\tw@}
% \DoNotIndex{\typeout}
% \DoNotIndex{\xdef}
% \DoNotIndex{\z@}
%
%
% \section{Introduction}
%
% \subsection{A quick overview of \LaTeX's float algorithm}
%
%   \LaTeX{}'s output routine uses a greedy algorithm to place floats
%   near to their appearance in the source document. The decision how
%   to place a float is made when the float is first encountered. If
%   possible it is placed onto the current page, either in mid-text,
%   on top or into the bottom area, depending on what is allowed for
%   the float and how many floats are already placed into those
%   areas. 
%
%   If the float can't be placed immediately it goes into a defer list
%   and in order to not accumulate too many unplaced floats \LaTeX{}
%   tries to empty that list whenever the is a chance. This chance
%   comes after the next page break: \LaTeX{} then start a special
%   ``float page'' algorithm  in which it examines the defer list and
%   forms float pages (i.e., pages that only contain floats) from
%   it. If necessary, it generates several  float pages and only stops
%   if there are no floats waiting to be placed or there are too few
%   floats to form a float page or there are only floats left that are
%   for one or the other reason not allowed to be placed in this way.
%
%   Finally \LaTeX{} looks at the remaining floats and tries to place
%   as many of them as possible into the top and bottom area of the
%   next page. Then it continues to process further text to fill the
%   text part of that page. Details on the exact behavior of the
%   algorithm are discussed in \cite{fmi:floatplacement}.
%
%
% \subsection{The typical float page and its problems}
%
%   \LaTeX{} considers a float page to be successfully build if its
%   floats take up more than \cs{floatpagefraction} of the whole
%   page. By default this parameter is set to \texttt{.5} which means
%   that such float pages may end up being nearly half empty.
%
%   Many users think that this not a good value and try to improve on
%   it by enforcing a higher percentage (such as 80\%) only to find
%   that this prevents \LaTeX{} in many cases from successfully
%   generating any float page, with the effect of all floats are
%   suddenly piling up at the end of the document.
%
%   Why is this the case? In a nutshell, because a higher percentage
%   makes it much more likely that there is a float that can't be
%   placed, because by itself it is not big enough to be used on its
%   own and there are no other floats nearby that can be combined with
%   it, because their combination violates some other restriction,
%   e.g., together they are bigger than a page, not all of them are
%   allowed to go on float pages, etc. The moment that happens this
%   floats prevents the placement of all other floats of the same
%   class too (i.e., all figures) and disaster is ensured. In most
%   cases these floats will then never get placed, because they need a
%   float of the right size from a different class to appear, which
%   may in theory happen but is, unfortunately, unlikely.
%
%   Thus, while tempting, tinkering with this parameter by making it
%   larger is usually not a good idea, unless you are prepared to place
%   most if not all of your floats manually, by overwriting the
%   placement algorithm on the level of individual floats (e.g., using
%   \texttt{!}\@ syntax and/or shifting its position in the source
%   document).
%
%   Why does the current algorithm has these problems? To some extend
%   because it offers only global parameters that need to fit
%   different scenarios and thus settings that are suitable when many floats
%   need to be placed then result in sub-optimal paginations in
%   document parts that only contain a few floats and vice versa.
%   To overcome this problem, one can either try to develop algorithms
%   with many more configurable parameters that act differently in
%   different scenarios or to let the algorithm follow a main strategy
%   configurable with only a few parameters (like today) but monitor
%   the process and make more local adjustements and corrections
%   depending on the actual outcome of the base strategy and knowledge
%   on the real inputs in a given document part. This is more
%   or less the approach taken by the extenion implemented in this
%   package.
%
% \section{Improvements to the float page algorithm}
%
%   A simple way to improve on the the existing algorithm, without
%   compromising its main goal of placing the floats as fast as
%   possible and as close as possible to their call-outs, is the
%   following: as long as there are many floats waiting to be placed
%   generate float pages as necessary to get them placed (using the
%   current algorithm and its parameters). However, once we are unable
%   to build further float pages, do some level of backtracking by
%   checking if we have actually succeeded in placing all floats.
%
%   If there are still floats waiting to be placed then assume that
%   what as been done so far is the best possible way to place as many
%   floats as possible (which it probably is). However, if we have
%   been able to place all floats onto float pages then check if the
%   last float page is sufficiently full and if not undo the it and
%   instead redistribute its floats into the top and bottom area of
%   the next upcoming page. This way the floats will be combined with
%   further text and we avoid a possible half-empty float page.
%
%   This approach will not resolve all kind problematical scenarios
%   where we find that \LaTeX{} has decided to favor fairly empty
%   float pages over some tighter type of placement. It will, however,
%   help to improve typical cases that do not involve too many floats.
%   For\mnote{A typical case where we don't really want \LaTeX{} to
%   make a float page} a example, if a single (larger) float appears
%   near the end of a page, then using the standard algorithm it can't
%   be immediately placed (since there isn't enough free space on the
%   current page). It is therefore moved to the defer list and at the
%   page break it is then placed onto a float page (possibly by its
%   own, if it is large enough to allow for that) even though it could
%   perfectly well go into the top or bottom area of the next page and
%   thus be combined with textual material on that page.
%
%   With the new algorithm this float page is reexamined and unless it
%   is pretty much filled up already, it is unraveled and its floats
%   are redistributed into the top and bottom areas of the next page.
%   If, however, we have many floats waiting on the defer list, the
%   normal float page algorithm will first place as many of them as
%   possible into float pages and only the last of these pages will be
%   subject to a closer inspection and a possible unraveling.
%
%   An extension of this idea (and the one that we actually implement)
%   is to monitor the whole float page generation process and instead
%   of just considering the last float page in sequence for unraveling
%   look at each prospective float page in turn and based on the
%   current situation (e.g., number of floats still being unplaced,
%   free space on the float page, etc.)\@ decide whether this float
%   page should be produced or whether we should stop making float
%   pages and instead place the pending floats into top and bottom
%   areas of the upcoming page.
%
%
% \subsection{Details on the extended algorithm}
%
%   The main idea of the extended algorithm is to avoid unnecessary cases of
%   float pages especially if those float pages are fairly
%   empty.\mnote{Don't unravel a float page if there are too many
%    floats on the defer list}
%   Natural candidates are single float pages, but even in cases where
%   the current \LaTeX{} algorithm  produces several a sequence float
%   pages the extended algorithm may decide to replace them by normal
%   pages under certain conditions.
%   However, the main goal
%   is and should remain to place as many floats as soon as possible
%   and so generating float pages when many floats are waiting is
%   usually essential.
%
% \begin{variable}{floatpagedeferlimit}
%   \begin{syntax}
%   \cs{setcounter}\{floatpagedeferlimit\}\Arg{number}
%   \end{syntax}
%   Whether or not unraveling for a float page is considered at all,
%   is guided by the counter \ctr{floatpagedeferlimit} and as long as
%   there are more floats waiting on the defer list than this number,
%   float pages are not considered for unraveling.  The default is
%   \texttt{3} which corresponds to the default value for
%   \ctr{totalnumber}, i.e., with that setting the unraveling a
%   floating page has a fighting chance to place all floats into the
%   top and bottom areas on the current page.
%   It would also resolve cases such as up to three floats, each larger than
%   \cs{floatpagefraction}, where standard \LaTeX{} algorithm would
%   produce three individual float pages.
% \end{variable}
%
%   If you set the counter to \texttt{1} then only the last float page
%   in a sequence is considered and only if it contains only a single
%   float and if there are no other floats that are still waiting to
%   be placed.  If you set it to \texttt{0}, then the extension
%   is disabled since float pages are only produced if there was at
%   least one float on the defer list.
%
%   Even\mnote{Don't unravel if the float page contains many
%   floats} if we set \ctr{floatpagedeferlimit} to a fairly high value,
%   we may not want to unravel float pages that contain many
%   floats. To support this case there is a second counter that guides the
%   algorithm in this respect.
%
% \begin{variable}{floatpagekeeplimit}
%   \begin{syntax}
%   \cs{setcounter}\{floatpagekeeplimit\}\Arg{number}
%   \end{syntax}
%   Whenever the float page contains at least
%   \ctr{floatpagekeeplimit} floats it will not be unraveled. The
%   default is also \texttt{3} so that float pages with three or more
%   floats are not touched. Obviously the counter can have only any
%   effect if it has a value less or equal to
%   \ctr{floatpagedeferlimit} since this is tested first.
% \end{variable}
%
%
%   There are, however, a number of other situations in which we
%   shouldn't unravel a float page even if the above check for the
%   size of the defer list was passed successfully.\mnote{Don't
%   unravel if the float page contains at least one \texttt{\upshape
%   [p]} float} The most important one is the case when it contains at
%   least one float that is \emph{only} allowed on float pages (i.e.,
%   has a \texttt{[p]} argument). Since such a float would not be
%   placeable in a top/bottom area on any page and thus would be send
%   back to the defer list.
%
%   The other case where unraveling would normally be
%   counterproductive is when the particular float page is nearly or
%   completely filled up with floats.\mnote{Don't unravel if the float
%   page is nearly filled} If we would unravel it, then it is certain
%   that we can only place some of the floats into the top or bottom
%   area of the next page and some would end up on the
%   defer list. That in turn means that these deferred floats float
%   even further away from their call-out positions than they have to
%   be.
%
% \begin{function}{\floatpagekeepfraction}
% \begin{syntax}
%   \cs{renewcommand}\cs{floatpagekeepfraction}\Arg{decimal}
% \end{syntax}
%   So what is a good way to determine if a float page is ``full
%   enough''?  A possible answer is that if the remaining free space
%   on that page is less than \cs{textfraction} we consider it full
%   enough to stay. \cs{textfraction} defines the minimum amount of
%   space that has to be occupied by text on a normal page, thus if
%   all floats together need so much space that this amount of text
%   could not be fitted in, then trying to place all floats onto a
%   normal page can't succeed and some of them would get deferred for
%   sure.  To allow for some further flexibility the algorithm uses
%   the variable \cs{floatpagekeepfraction} (defaulting to
%   \cs{textfraction}) so if desired a lower (or even a higher)
%   boundary can be set.
% \end{function}
%
%   The above parameters give some reasonable configuration
%   possibilities to guide the algorithm when and when not to unravel
%   a possible float page and instead produce further normal pages.
%   It should be noted, however, that except for the case of setting
%   \ctr{floatpagedeferlimit} to \texttt{1}, there is always a chance
%   that floats drift further away from their call-outs, because the
%   may not be immediately placeable due to other parameter settings
%   of the float algorithm.  For example, the counter
%   \texttt{topnumber} (default value 2) limits the number of floats
%   that can be placed in the top area on a normal page and if more
%   remain after unraveling only two can immediately go in this area.
%
%
% \subsection{Possible pitfalls and how to avoid them}
%
%   The algorithm detects if a float is only allowed on float pages
%   (i.e., is given in the source as \texttt{[p]} and it will ensure
%   that float pages containing such floats are not unraveled.
%
%   However, if you have a float with the default specifier
%   \texttt{[tbp]} whose size is larger than the allowed size of the
%   top or bottom area (e.g., larger than \cs{topfraction}
%   \texttimes{} \cs{textheight}), then this effectively means it can
%   only be placed on float pages.
%
%   However, according to the specifier the float is allowed in to go
%   into the top or bottom area, so the algorithm as explained so far
%   would be allowed to unravel and when that float later is
%   considered for top or bottom placement it will get again deferred and
%   thus move from one page to the next, most likely messing up the
%   whole float placement.
%
%   There\mnote{\option{checktb} (option)} are two possible ways how
%   the algorithm could be improved to avoid this disaster. One way
%   would be to check the float size when it is initially encountered
%   and  remove any specifiers that are technically not possible
%   because of the parameter settings and the float size. The
%   disadvantage of this approach is that we will get more floats that
%   have only a \texttt{p} specifiers, i.e., that there will be more float
%   pages in the end.
%   If you prefer the first approach
%   specify the option \option{checktb}. In that case you might see
%    warnings like
%\begin{verbatim}
% LaTeX Warning: Float too large for top area: t changed to p on line ...
%\end{verbatim}
%
%   Another\mnote{Default action is to add \texttt{!}\@ specifiers
%   during unraveling} possibility is that we automatically add a
%   \texttt{!}\@  specifier to all floats during unraveling, i.e., when
%   we send them back for reevaluation This way such floats become
%   placeable into top and bottom areas regardless of their size. This
%   is the default action that the algorithm uses if no option is
%   specified.
%
%   If\mnote{\option{nobang} (option)} you prefer neither automatic
%   specifier change add the option \option{nobang}.
%
%   In this case you might find that floats of certain sizes to be
%   unplaceable and thus getting delayed to the end of the document.
%   If that happens the remedy is to either explicitly specify
%   \texttt{[p]} or \texttt{[hp]}for such a float (to ensure that they
%   aren't subject to unraveling) or to manually add an exclamation
%   specifier, e.g., \texttt{[!tp]} so that \LaTeX{} doesn't use the
%   size restrictions in its algorithm.
%
%
%
% \subsection{Tracing the algorithm}
%
%   The\mnote{\option{trace} (option)} package offers the option
%   \option{trace}, which if used, will result in messages such as
%\begin{verbatim}
%  [1]
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@B \bx@D 
%  lessfloatpages:  starting with \bx@B
%  lessfloatpages:  --> success:  \bx@B \bx@D 
%  lessfloatpages: ----- current float page unraveled
%                  (free space 192.50336pt > 109.99832pt)
%  [2]
%\end{verbatim}
%   which means that the algorithm is trying to make a float page from
%   the defer list which at that point contained two floats (the float
%   boxes \cs[no-index]{bx@B} and \cs[no-index]{bx@D}), that it was able to produce a
%   float page just containing  \cs[no-index]{bx@D} and that the extended algorithm then
%   decided to unravel that float page, because it has an unused
%   space of \texttt{192.5pt} and with the current
%   \cs{floatpagekeepfraction} that is too much.
%
%   Or it might say
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@D \bx@F \bx@G \bx@H \bx@I 
%  lessfloatpages:  starting with \bx@D
%  lessfloatpages:  --> success: \bx@D \bx@F 
%  lessfloatpages: ----- too many deferred floats for unraveling (5 > 3)
%  [3]
%\end{verbatim}
%   which means that the algorithm made a float page out of the first
%   two floats from the defer list (i.e., 3 remained).
%   That
%   page was kept regardless of the amount of free space it contained
%   because we have a total of 5 floats on the defer list and the
%   counter \ctr{floatpagedeferlimit} has its default values o \texttt{3}.
%
%   The above message examples are actually from the same test
%   document. What they also show (implicitly) is that the unraveling
%   that happened after page~1 resulted in only one float (\cs[no-index]{bx@B})
%   being placed on page~2, because we see the second one (\cs[no-index]{bx@D})
%   reappearing in the defer list after page~2 got finished. In other
%   words it was moved one page further away from its call-out: the
%   price for getting a nicely filled page~2 instead of a fairly empty
%   float page with roughly 200 points left free (i.e., about 16 lines
%   of normal text).
%   The final part of that test document then exhibits another
%   type of message:
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@G \bx@H \bx@I 
%  lessfloatpages:  starting with \bx@G
%  lessfloatpages:  --> success: \bx@G \bx@H \bx@I 
%  lessfloatpages: ----- all floats placed on float page(s)
%  lessfloatpages: ----- current float page kept, full enough
%                        (free space 38.99496pt < 109.99832pt)
%  [4]
%\end{verbatim}
%   This means that the remaining floats (that were left unplaced
%   after float page~3 got constructed) by themselves formed a float
%   page and that float page was the last in sequence (i.e., all
%   floats have been placed). However, this time the algorithm decided not
%   to unravel it, because it is nicely full: there are only 39 points
%   of free space left on that page.
%
%   Three other possible messages are shown in this sequence of
%   typeouts from a second test document (which is using some uncommon
%   settings (\ctr{floatpagedeferlimit} is \texttt{10} and
%   \ctr{floatpagekeeplimit} is \texttt{5}):
%\begin{verbatim}
%  [1]
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@B \bx@C \bx@D \bx@E \bx@F \bx@G \bx@H 
%  lessfloatpages:  starting with \bx@B
%  lessfloatpages:  --> success: \bx@B \bx@C \bx@D \bx@E \bx@F \bx@G \bx@H 
%  lessfloatpages: ----- current float page kept (contains at least 5 floats)
%  [2] [3]
%\end{verbatim}
%   In this case 7 floats have been waiting on the defer list and the
%   algorithm was able to construct a float page using all of them.
%   The algorithm then keeps that page because it has 5 or more floats
%   in it (the value of the\ctr{floatpagekeeplimit} counter).
%
%   The next message in that test document then shows what happens
%   when there are not enough floats waiting or they are simply too
%   small (to even get passed the \cs{floatpagefraction} limit):
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@I \bx@J 
%  lessfloatpages:  starting with \bx@I
%  lessfloatpages:  --> fail
%  lessfloatpages:  starting with \bx@J
%  lessfloatpages:  --> fail
%  lessfloatpages:  --> fail: no float page made
%  [4]
%\end{verbatim}
%   So no float page was made, but for some reason (that becomes clear
%   later) the two floats also didn't got distributed into the top or
%   bottom area of the next page. Instead they remained on the
%   defer list and during processing of page~4 one more float was
%   found so that after that page the defer list had grown to
%   length~3:
%
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@I \bx@J \bx@K 
%  lessfloatpages:  starting with \bx@I
%  lessfloatpages:  --> success: \bx@I \bx@J \bx@K 
%  lessfloatpages: ----- current float page kept, contains a float
%  lessfloatpages:       with p but no t or b specifier
%  [5]
%\end{verbatim}
%   This time all floats could be placed, but again the float page
%   wasn't unraveled (even though in the test document it contained a
%   lot of white space) because of the fact that one of its floats (in fact
%   the first though that can only be deduced implicitly) was
%   specified as a \enquote{float page only} float. This explains why
%   on page~4 \cs[no-index]{bx@I} couldn't be placed into the top or bottom
%   area and then all following floats of the same class (the test
%   document only contained \env{figure} floats) couldn't be placed
%   either.
%
%   If\mnote{Detailed tracing of the complete algorithm} you want
%   detailed tracing of the complete algorithm, also load the
%   \pkg{fltrace} package and enable the tracing with
%   \cs{tracefloats} anywhere in your document. Note, however, that
%   the resulting output is very detailed but rather low-level and
%   unpolished.
%
%
%
%
%
% \subsection{Local adjustments}
%
%   If the extended algorithm is used you will get less float pages
%   that contain a noticeable amount of white space. By adjusting
%   \cs{floatpagekeepfraction} and the counters \ctr{floatpagekeeplimit} and
%   \ctr{floatpagedeferlimit} you can direct the algorithm to unravel more or
%   less of the otherwise generate float pages. However, in some cases
%   it might happen that redistribution of the floats into the top and
%   bottom areas of the next page(s) may result in some of them
%   drifting too far away from their call-outs. If that happen you can
%   either try to change the general parameters or you could help the
%   algorithm along by using the optional argument of individual float
%   environments.
%   The two main tools at your disposal are
%   \begin{itemize}
%   \item
%     using the \texttt{[!..]} notation to allow the float to go into
%     the top or bottom area even if it would be normally prevented by
%     other restrictions;
%   \item
%     using \texttt{[p]} to force a float into a float page as that
%     prevents the algorithm to unravel the float page which contains
%     that float.
%   \end{itemize}
%   As an alternative you can, of course, temporarily alter the
%   definition of the command \cs{floatpagekeepfraction} or the values
%   of two counters in mid-document, but remember that they are not
%   looked at when a float is encountered in the source but when we
%   are at a page break and \LaTeX{} attempts to empty the defer list,
%   which is usually later and unfortunately somewhat asynchronous,
%   i.e., not easy to predict.
%
%
% \StopEventually{
% \begin{thebibliography}{1}
% \raggedright
% \bibitem{fmi:floatplacement}
% Frank Mittelbach.
% \newblock How to influence the position of float environments like figure and table in \LaTeX?
% \newblock \textsl{TUG}boat 35:3, 2014.\\
% \newblock \url{https://www.latex-project.org/publications/indexbytopic/2e-floats/}
% \bibitem{source2e}
% \LaTeX{} Project Team.
% \newblock The \LaTeXe{} Sources (660+ pages), 2018.\\
% \newblock \url{https://www.latex-project.org/help/documentation}
%\end{thebibliography}
% \ifx\thisissuepageref\undefined    ^^A is this TUB production ??? if not gen index
%    \setlength\IndexMin{200pt}  \PrintIndex
% \fi}
%
%
%
% \section{The Implementation}
%
%    We start off with package announcement. Requiring a fairly new
%    \LaTeX{} kernel is not absolutely necessary but it will help to
%    ensure that we patch what we think we patch and in the future it
%    means that will can be assured that the rollback functionality of
%    the kernel is available in case will need to support several
%    releases of the package.
%    \begin{macrocode}
%<*package>
\NeedsTeXFormat{LaTeX2e}[2018-04-01]
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesPackage{lessfloatpages}
                [\lessfloatpagesdate\space
                 \lessfloatpagesversion\space
                 improve float page generation (FMi)]
%    \end{macrocode}
%
% \subsection{Option handling}
%                
%    This release of the package has three options: \option{trace}
%    for tracing the algorithm and \option{nobang} and
%    \option{checktb} to handle cases where the float size in
%    combination with the float specifiers makes it difficult if not
%    impossible to places the floats.
%                
%    The option \option{trace} enables tracing of the algorithm and is
%    implemented by giving the command \cs[no-index]{fl@trace} (which is also
%    used by the \pkg{fltrace} package) a suitable definition.
%
%    To cater for the case that the \pkg{fltrace} package is loaded
%    first, we use \cs[no-index]{providecommand}, so that its definition is not
%    overwritten, but used if it is already in available. If the package is
%    loaded later everything works fine because it unconditionally
%    defines \cs[no-index]{fl@trace}, i.e., overwrites whatever
%   \pkg{lessfloatpages} has defined.
%
%    \begin{macrocode}
\DeclareOption{trace}
              {\providecommand\fl@trace[1]%
                {{\let\@elt\@empty\typeout{lessfloatpages: #1}}}}
%    \end{macrocode}
%
%    By default the algorithm adds a \texttt{!}\@ to floats that are
%    send back for reevaluation when a float pages gets
%    unraveled. With \option{nobang} this action is suppressed at the
%    cost that some floats may float to the end of the document.
%    \begin{macrocode}
\DeclareOption{nobang}
              {\let\fp@maybe@add@bang\@gobble}
%    \end{macrocode}
%    
%    Option \option{checktb} implements a different approach to
%    handling problematic floats. If used the vertical size of a float
%    is checked and if it is too large to be allowed into the top or
%    the bottom area any \texttt{t} or \texttt{b} specifier is
%    replaced by \texttt{p} (or dropped if \texttt{p} is already
%    specified). This option implies \option{nobang}.
%
%    The real definition for \cs{fp@maybe@check@tb} is done later, be
%    setting it to \cs[no-index]{relax} we are only signalling here that the
%    option was given.               
%    \begin{macrocode}
\DeclareOption{checktb}
              {\let\fp@maybe@check@tb\relax
               \let\fp@maybe@add@bang\@gobble}
\ProcessOptions
%    \end{macrocode}
%
%
% \subsection{Tracing code}
%                
%  \begin{macro}[internal]{\fl@trace}
%    The command \cs[no-index]{fl@trace} is used to output tracing information.
%    By default the tracing of the algorithm is turned off, so
%    \cs[no-index]{fl@trace} will simply swallow its argument. But if
%    \pkg{fltrace} is loaded or the option \option{trace} is given
%    then the command already has a definition so we don't change it
%    here.
%    \begin{macrocode}
\providecommand\fl@trace[1]{}
%    \end{macrocode}
%  \end{macro}
%
%
% \subsection{User-level interfaces}
%
%    For the most part the packages provides internal code that
%    extends the float algorithm of \LaTeX{}. There are, however, also
%    three new parameters the guide this algorithm, they are defined
%    in this section.
%
%  \begin{macro}[var]{\floatpagekeepfraction}
%    The fraction that the algorithm uses to decide that a given float
%    page is so full that it would be pointless to unravel it for the
%    reasons outlined above. The default is whatever fraction has been
%    chosen as the minim amount of text that need to be on a normal
%    page (i.e., \cs{textfraction}).
%    \begin{macrocode}
\newcommand\floatpagekeepfraction{\textfraction}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}[var]{floatpagedeferlimit,\c@floatpagedeferlimit}

%    The algorithm will only consider unraveling float pages if are
%    are not too many floats on the defer list. The definition of
%    \enquote{too many} is provided through the counter
%    \ctr{floatpagedeferlimit} if there are more floats waiting to be
%    placed, float pages are generated until their number falls below
%    this level. Thus, a value of \texttt{0} will disable the whole
%    algorithm and a value of \texttt{1} means that only float pages
%    with a single float might get unraveled and only if there aren't
%    others still waiting to be placed.
%    \begin{macrocode}
\newcounter{floatpagedeferlimit}
\setcounter{floatpagedeferlimit}{3}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}[var]{floatpagekeeplimit,\c@floatpagekeeplimit}
%
%    A float page that contains at least this number of floats will
%    also be kept. The default is \texttt{3} but if you have a lot of
%    small floats it might be better to set this to a higher
%    value.
%    \begin{macrocode}
\newcounter{floatpagekeeplimit}
\setcounter{floatpagekeeplimit}{3}
%    \end{macrocode}
%  \end{macro}





% \subsection{Patching the \LaTeX{} kernel commands}
%                


%
%  \begin{macro}[internal]{\@tryfcolumn}
%    The main macro we have to patch to extend \LaTeX's algorithm is
%    \cs{@tryfcolumn}. That command is changed when \pkg{fltrace}
%    gets loaded, so we make our definition as late as possible to
%    ensure that it will survive.
%    \begin{macrocode}
\AtBeginDocument{%
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \@tryfcolumn #1{%
  \global \@fcolmadefalse
  \ifx #1\@empty
  \else
    \fl@trace{PAGE: trying to make a float
                    \if@twocolumn column/page\else page\fi}%
    \fl@trace{----- \string #1: #1}%
    \xdef\@trylist{#1}%
    \global \let \@failedlist \@empty
    \begingroup
      \let \@elt \@xtryfc \@trylist
    \endgroup
%    \end{macrocode}
%    Up to this point the definition is the same as in the original
%    algorithm. At this point the  switch \cs[no-index]{if@fcolmade}  tells us if making a
%    float page was successful and the original algorithm then called
%    \cs{@vtryfc} and removed the floats used for this float page from the defer list.
%
%    In the extended algorithm this is the place where things start to
%    differ as we may not want that float page to actually come into
%    existence.
%    \begin{macrocode}
    \if@fcolmade
%    \end{macrocode}
%    As a first step we count the number of floats in the defer list
%    and save the result in \cs{fp@candidates}.
%    \begin{macrocode}
      \fp@candidates\z@
      \def\@elt##1{\advance\fp@candidates\@ne}%
        #1%
      \let\@elt\relax
%    \end{macrocode}
%    Now we compare this number with the values of the counter \ctr{floatpagedeferlimit}
%    and if it is higher we definitely want to keep the float
%    page. The rationale is that if we unravel that all floats from
%    the defer list need to go into the top/bottom areas (or get
%    deferred again) and so a high number means the defer list will
%    not get shortened very much and too many floats will get delayed further.
%    \begin{macrocode}
      \ifnum \fp@candidates >\c@floatpagedeferlimit
        \fl@trace{----- too many deferred floats for unraveling
                   (\the\fp@candidates\space> \the\c@floatpagedeferlimit)}%
      \else
%    \end{macrocode}
%
%    Otherwise we do a bit more testing. First we set \cs[no-index]{if@fcolmade}
%    back to false, after all our goal is to not  keep the float page. If
%    during the tests we decide otherwise we set it back to true which
%    then signals that it should stay.
%
%    We also count the floats on the float page and reuse \cs{fp@candidates}
%    for that which is why we initialize it to zero.
%    \begin{macrocode}
        \global\@fcolmadefalse
        \fp@candidates\z@
%    \end{macrocode}
%    The actually checking is done with
%    \cs{fp@analyse@floats@for@unraveling} and it loops over
%    \cs{@flsucceed}, i.e., the floats for that float page. This
%    checks if any float has only a \texttt{[p]} specifier and if so
%    sets \cs[no-index]{if@fcolmade} back to \texttt{true} and as a side effect also does
%    the counting for us.
%    \begin{macrocode}
        \let\@elt\fp@analyse@floats@for@unraveling
          \@flsucceed
        \let\@elt\relax
%    \end{macrocode}
%    Now we recheck the state of the switch and if it still says
%    \texttt{false} all tests indicated that we don't want the float
%    page.
%    \begin{macrocode}
        \if@fcolmade
        \else
%    \end{macrocode}
%    But we aren't done yet: the float page might be nicely filled,
%    which case it would be a shame to unravel it. During the above
%    loop we also measured the free space on the float page and stored
%    it in \cs{fp@unused@space} (see \cs{@xtryfc} below). We now
%    compare that to the maximum free space that we consider to be
%    still okay and if there is more we finally do the unraveling.
%    \begin{macrocode}
          \@tempdima\floatpagekeepfraction\@colht
          \ifdim \fp@unused@space >\@tempdima
            \fl@trace{----- current float page unraveled^^J%
                      \@spaces\@spaces\@spaces\space\space\space
                      (free space \fp@unused@space\space > \the\@tempdima)}%
%    \end{macrocode}
%    For this be basically return all floats back to the
%    defer list. The switch is still \texttt{false} so it doesn't need
%    changing.
%    \begin{macrocode}
            \xdef #1{\@failedlist\@flsucceed\@flfail}%
%    \end{macrocode}
%    However, we also want to add a \texttt{!}\@ specifier to each of
%    the floats (unless the user specified the \option{nobang} option)
%    so we loop over all the floats once more to get this
%    done.\footnote{This could have been integrated with
%    \cs{fp@analyse@floats@for@unraveling} but there is not much gain if
%    any and keeping it separate the processing logic seems clearer to me.}
%    \begin{macrocode}
            \let\@elt\fp@maybe@add@bang
              \@flsucceed
            \let\@elt\relax
          \else
%    \end{macrocode}
%    But if we want to keep the float page after all, we have to set
%    the switch back to \texttt{true} so that the rest of the
%    algorithm proceeds correctly.
%    \begin{macrocode}
            \global \@fcolmadetrue
            \fl@trace{----- current float page kept, full enough^^J%
                      \@spaces\@spaces\@spaces\space\space\space
                      (free space \fp@unused@space\space < \the\@tempdima)}%
          \fi
        \fi
      \fi
%    \end{macrocode}
%    The next \cs[no-index]{else} matches the first \cs[no-index]{if@fcolmade}, i.e., the
%    case that the algorithm wasn't able to make any float page and if
%    we are tracing the algorithm, we want to tell the user about this.
%    \begin{macrocode}
    \else
      \fl@trace{ --> fail: no float page made}%
    \fi
%    \end{macrocode}
%    
%    Finally, at this point we are back in the original algorithm. Now the
%    switch tells the truth about whether or not we want to make a float
%    page and if so we go ahead and produce it.
%    \begin{macrocode}
    \if@fcolmade
        \@vtryfc #1%
    \fi
  \fi
}%
}    % -- END of \AtBeginDocument
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}[internal]{\@makefcolumn}
%
%    In contrast to \cs{@tryfcolumn} this macro will always make float
%    pages out of the deferred floats. It is used by \cs{clearpage}
%    when we really need the floats to get out and there is no further
%    text coming up. Thus, in that case we should not unravel the
%    float pages. That would happen with the kernel definition of
%    \cs{@makefcolumn} as that calls \cs{@tryfcolumn} which we just
%    changed above. We therefore modify its definition to use the
%    original code for \cs{@tryfcolumn} instead of calling our updated
%    version.
%
%    Again this change is made at \verb=\begin{document}= so that it
%    is not overwritten in case \pkg{fltrace} is loaded afterwards.
%    \begin{macrocode}
\AtBeginDocument{%
\def\@makefcolumn #1{%
  \begingroup
    \@fpmin -\maxdimen
    \let \@testfp \@gobble
%    \end{macrocode}
%    At this point the original definition called \cs{@tryfcolumn} and
%    the lines above ensured that it was always succeeding in making
%    a float page. However, since we have changed that command to do unraveling
%    we better not use it any more. Instead we replace it by its original
%    definition (with the addition of two tracing lines).
%    \begin{macrocode}
    \global \@fcolmadefalse
    \ifx #1\@empty
    \else
      \fl@trace{PAGE: trying to make a float
                      \if@twocolumn column/page\else page\fi}%
      \fl@trace{----- \string #1: #1}%
      \xdef\@trylist{#1}%
      \global \let \@failedlist \@empty
      \begingroup
        \let \@elt \@xtryfc \@trylist
      \endgroup
      \if@fcolmade
        \@vtryfc #1%
      \fi
    \fi
  \endgroup
}%
}  % -- END of \AtBeginDocument
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}[internal]{\@xtryfc}
%    The only change to \cs{@xtryfc} is the addition of the
%    \cs[no-index]{fl@trace} calls. But this extra tracing info is generally
%    useful and should also be done in the \pkg{fltrace} package.
%
%    The macro initiates a float page trial starting with the first
%    float in \cs{@trylist}. More detailed explanations can be found
%    in the documented sources of the \LaTeX{} kernel~\cite{source2e}.
%    \begin{macrocode}
\def\@xtryfc #1{%
  \fl@trace{ starting with \string#1}%
  \@next\reserved@a\@trylist{}{}%
  \@currtype \count #1%
  \divide\@currtype\@xxxii
  \multiply\@currtype\@xxxii
  \@bitor \@currtype \@failedlist
  \@testfp #1%
  \@testwrongwidth #1%
  \ifdim \ht #1>\@colht
     \@testtrue
  \fi
  \if@test
    \@cons\@failedlist #1%
    \fl@trace{ --> fail}%
  \else
    \@ytryfc #1%
  \fi
}%
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%  \begin{macro}[internal]{\@ytryfc}
%
%    The command \cs{@ytryfc}, which is also part of the code in the
%    kernel, loops through the defer list and tries to build a float
%    page starting with the float pass to it in |#1|. If it suceeds,
%    the floats that are part of the float page are listed in
%    \cs{@flsucceed} and the switch \cs[no-index]{if@fcolmade} is set to
%    \texttt{true}. Interesting for us is that inside the code
%    \cs[no-index]{@tempdima} holds the size taken up by the floats, so we can
%    use this to calculate the unsued space on the float page and
%    store it in \cs{fp@unused@space} for use in our extended
%    algorithm.
%    \begin{macrocode}
\def\@ytryfc #1{%
  \begingroup
    \gdef\@flsucceed{\@elt #1}%
    \global\let\@flfail\@empty
    \@tempdima\ht #1%
    \let\@elt\@ztryfc
    \@trylist
    \ifdim \@tempdima >\@fpmin
      \global\@fcolmadetrue
%    \end{macrocode}
%    This branch is executed when the floats together are big enough
%   to form a float page. Thus, this is the right place to calculate
%   the free space by substracting the used space from the column
%   height (which may not be the full height if there are spanning
%   floats in two column mode).
%    \begin{macrocode}
      \@tempdimb\@colht
      \advance\@tempdimb-\@tempdima
      \xdef\fp@unused@space{\the\@tempdimb}%
%    \end{macrocode}
%    The remaining code is again unchanged except that we added two
%    additional tracing lines (though those should be added to
%    the \pkg{fltrace} package too one of these days).
%    \begin{macrocode}
    \else
      \@cons\@failedlist #1%
      \fl@trace{ --> fail}%
    \fi
  \endgroup
  \if@fcolmade
    \let\@elt\@gobble
    \fl@trace{ --> success: \@flsucceed}%
  \fi}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}[internal]{\@largefloatcheck}
%
%    The final kernel macro we need to patch is
%    \cs{@largefloatcheck}. This is called when a float box is
%    constructed and it checks if that box is larger than the availale
%    \cs{textheight} which would mean it could never be placed
%    anywhere, not even on a float page. The code therefore reduces
%    the box size as necessary and issues a warning.
%
%    This macro is therefore a natural candidate to also check if the
%    float size is too large for the float to go into top or bottom
%    areas (if the option \option{checktb} is used.
%    \begin{macrocode}
\def \@largefloatcheck{%
  \ifdim \ht\@currbox>\textheight
    \@tempdima -\textheight
    \advance \@tempdima \ht\@currbox
    \@latex@warning {Float too large for page by \the\@tempdima}%
    \ht\@currbox \textheight
  \fi    
%    \end{macrocode}
%    The \cs{fp@maybe@check@tb} does the checking (or nothing if the
%    option is not given).
%    \begin{macrocode}
  \fp@maybe@check@tb
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
% \subsection{Internal helpers commands and parameters}
%                
%
%  \begin{macro}[internal]{fp@candidates}
%     We use an internal counter to count the number of floats in the
%    defer list and on a float page under construction.
%    \begin{macrocode}
\newcount\fp@candidates
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}[internal]{\fp@unused@space}
%    In \cs{fp@unused@space} which we store the amount of free space
%    on the current float page.
%    \begin{macrocode}
\def\fp@unused@space{}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}[internal]{\fp@analyse@floats@for@unraveling}
%    With \cs{fp@analyse@floats@for@unraveling} we loop over the
%    floats on the float page, i.e., |#1| will be one of such floats.
%
%    Its task is to count the floats (in \cs{fp@candidates}) check if
%    there are at least \ctr{floatpagekeeplimit} of them (which means
%    the float page should definitely be kept).
%
%    The most important task, however is to check if one of the floats
%    has only a \texttt{p} specifier but no other. In that case it is
%    essential that we aren't unraveling the float page because such a
%    float would then only go back onto the defer list as it has no
%    place to go except a float page.
%    \begin{macrocode}
\def\fp@analyse@floats@for@unraveling#1{%
  \advance\fp@candidates\@ne
  \ifnum \fp@candidates <\c@floatpagekeeplimit
%    \end{macrocode}
%    So far we haven't got enough floats to know that this float page
%    should be kept so we check the given float specifiers.
%  
%    The test may look a little weird,\footnote{\enquote{Little} might
%    be an understatement. Encoding a lot of information in individual
%    bits of the counter value associated with a float was a great way
%    in the early days of \LaTeX{} to preserve macro space (and
%    absolutely essential back then), but these days \ldots{} Anyway,
%    it is the way it is and that part can't really be changed without
%    breaking a lot of packages.}  but what we want to know is this:
%    is there are \texttt{p} (third bit) but neither a \texttt{b}
%    (second bit) nor a \texttt{t} (first bit). We don't care about
%    \texttt{h} or \texttt{!} which are the next two bit in the float
%    counter nor any of its higher bits (which encode the type of
%    float). So we devide the integer number by 8 which which drops
%    the two least significant bits if you think of the integer being
%    represented in binary format and then multiply it again by 8. As
%    a result the first two bits are zeroed out.  We then compare the
%    result with the original value and if the two values are the same
%    then the \texttt{b} and \texttt{t} bits must both have been zero
%    from the start. And since the float was on a float page we also
%    know that it had a \texttt{p} specifier.
%    \begin{macrocode}
    \@tempcntb\count#1%
    \divide\@tempcntb 8\relax
    \multiply\@tempcntb 8\relax
    \ifnum \count#1=\@tempcntb
%    \end{macrocode}
%    In that case we set \cs[no-index]{if@fcolmade} to \texttt{true} to signal that
%    this float page should be kept, generate a tracing message and change
%    \cs[no-index]{@elt} to becomes \cs[no-index]{@gobble} to quickly jump over any
%    remaining floats in the loop without doing further tests or
%    generating further tracing messages.
%    \begin{macrocode}
      \global \@fcolmadetrue
      \fl@trace{----- current float page kept, contains a float}%
      \fl@trace{\@spaces\space\space with p but no t or b specifier}%
      \let\@elt\@gobble
    \fi
%    \end{macrocode}
%    On the other hand, if we have seen enough floats we also know
%    that the float page should be kept, so change the switch, give
%    some tracing info and stop checking:
%    \begin{macrocode}
  \else
    \global \@fcolmadetrue
    \fl@trace{----- current float page kept
              (contains at least \the\fp@candidates\space floats)}%
    \let\@elt\@gobble
  \fi
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}[internal]{\fp@maybe@add@bang}
%
%    The helper \cs{fp@maybe@add@bang} is used to loop through all of
%    the floats of a float page (received each as |#1| in turn) and
%    add a \texttt{!}\@ specifier if there wasn't one before.
%
%    However, we only define it if it wasn't defined earlier in the
%    code for one of the options.
%    \begin{macrocode}
\ifx\fp@maybe@add@bang\@undefined
  \def\fp@maybe@add@bang#1{%
%    \end{macrocode}
%    Find out if the fourth bit is set (which means no \texttt{!}\@)
%    and if so substract 16 from the float counter which means setting
%    it to zero.
%    \begin{macrocode}
    \@boxfpsbit #1\sixt@@n
    \ifodd \@tempcnta
      \global\advance\count#1-\sixt@@n
    \fi
  }
\fi
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}[internal]{\fp@maybe@check@tb}
%    The code in \cs{fp@maybe@check@tb} is used in
%    \cs{@largefloatcheck} to test if the float has a \texttt{t} or
%    \texttt{b} specifier but is too large to fit into the the
%    respective area. This test is not made by default but only if the
%    option \option{checktb} is used, so we could have defined it
%    inside the option. But to keep the option section simple we only
%    gave it a trivial definition there so that we can now check if it
%    is defined, if so the option was given.
%    \begin{macrocode}
\ifx\fp@maybe@check@tb\@undefined
%    \end{macrocode}
%    If the option was not given we don't do any checking so we define
%    it to do nothing.
%    \begin{macrocode}
  \let\fp@maybe@check@tb\relax
\else
%    \end{macrocode}
%    Otherwise it gets a real definition. Again this is a case of
%    looking at various bits in the float counter value in binary
%    notation.
%    \begin{macrocode}
  \def\fp@maybe@check@tb{%
%    \end{macrocode}
%    If the specifier contained a \texttt{!}\@ we are ok, because in
%    that case size restrictions for areas do not apply. For this we
%    have to test the fourth bit which means dividing by 16 and then
%    checking if the result is odd or even (odd means there was no
%    \texttt{!}\@)\footnote{I'm sure we had very good reasons to
%    implement it this way in 1992\Dash we probably saved a few bytes
%    which was important back then. But it is certainly odd that for
%    \texttt{!}\@ a value of zero means that it was specified on the
%    float while for all other specifiers a value of \texttt{1}
%    indicates that the specifier was given.}. The kernel
%    \cs{@getfpsbit} does this for us and stores the result in
%    \cs[no-index]{@tempcnta} so we can test this with \cs[no-index]{ifodd} to see if the
%    bit was set.
%    \begin{macrocode}
    \@getfpsbit \sixt@@n
    \ifodd \@tempcnta
%    \end{macrocode}
%    If there was no \texttt{!}\@ we check if the height of the
%    float is too large to fit into the top area.
%    \begin{macrocode}
      \ifdim \ht\@currbox>\topfraction\textheight
%    \end{macrocode}
%
%    If that is the case we also check the first bit of the float
%    counter to see if a \texttt{t} was specified. For this we use
%    \cs{@getfpsbit} again but this time with \texttt{2} as argument
%    since we test the first bit.
%    \begin{macrocode}
        \@getfpsbit \tw@
        \ifodd \@tempcnta
%    \end{macrocode}
%    If \texttt{t}  was specified we need to remove it (next line) and
%    add (if not already present) a \texttt{p} instead. This is done
%    by \cs{fp@add@p@bit}. Finally we add a warning for the user about
%    the change.
%    \begin{macrocode}
          \global\advance\count\@currbox -\tw@
          \fp@add@p@bit
          \@latex@warning {Float too large for top area: t changed to p}%
        \fi
      \fi
%    \end{macrocode}
%    A similar test and action is needed for bottom floats, here we
%    need to look at and zero out the second bit (i.e., using 4 as a value).
%    \begin{macrocode}
      \ifdim \ht\@currbox>\bottomfraction\textheight
        \@getfpsbit 4\relax
        \ifodd \@tempcnta 
          \global\advance\count\@currbox -4\relax
          \fp@add@p@bit
          \@latex@warning {Float too large for bottom area:
                           b changed to p}%
        \fi
      \fi
    \fi
  }
\fi  
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}[internal]{\fp@add@p@bit}
%    The command \cs{fp@add@p@bit} adds the \texttt{p} specifier which
%    means checking the third bit and if not set, adding 8 to the float  counter.
%    \begin{macrocode}
\def\fp@add@p@bit{%
   \@getfpsbit 8\relax
   \ifodd \@tempcnta
   \else
     \global\advance\count\@currbox 8\relax
   \fi
}
%    \end{macrocode}
%  \end{macro}
%
%
%
% \subsection{Patches that will go into \pkg{fltrace} eventually}
%
%  The \pkg{lessfloatpages} package added some additional general
%  tracing info into some of the kernel functions which isn't
%  currently available when using only the \pkg{fltrace} package. As
%  that tracing info is generally useful for understanding what the
%  base part of the float algorithm does it should be also added to
%  the latter package.

%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% \Finale
%


\endinput

@boxfpsbit
@colht
@failedlist
@fcolmadefalse
@fcolmadetrue
@flfail
@flsucceed
@getfpsbit
@largefloatcheck
@latex@warning
@makefcolumn
@testfp
@tryfcolumn
@trylist
@xtryfc
@ytryfc
AtBeginDocument
DeclareOption
ProcessOptions
ProvidesPackage
bottomfraction
c@floatpagedeferlimit
c@floatpagekeeplimit
clearpage
floatpagedeferlimit
floatpagefraction
floatpagekeepfraction
floatpagekeeplimit
fp@add@p@bit
fp@analyse@floats@for@unraveling
fp@candidates
fp@maybe@add@bang
fp@maybe@checktb
fp@unused@space
if@fcolmade
lessfloatpagesdate
lessfloatpagesversion
setcounter
textfraction
textheight
topfraction
tracefloats
