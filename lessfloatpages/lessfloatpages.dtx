% \iffalse meta-comment
%
%% File: lessfloatpages.dtx (C) Copyright 2019 Frank Mittelbach
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% The development version of the bundle can be found below
%
%    https://github.com/FrankMittelbach/fmitex/
%
% for those people who are interested or want to report an issue.
%

\def\lessfloatpagesdate   {2019/08/01}
\def\lessfloatpagesversion{prerelease}     %{v1.0a}


%<*driver>
\documentclass
    [final]
    {l3doc-TUB}

\makeatletter
  \@mparswitchfalse
\makeatother
    
\setcounter{page}{1}       

\newcommand\ctr[1]{\texttt{\upshape#1}}
\newcommand\option[1]{\texttt{\upshape#1}}
\newcommand\mnote[1]{\marginpar{\raggedleft\em #1}}

\usepackage{csquotes}
\EnableCrossrefs
\CodelineIndex
\begin{document}
 \DocInput{lessfloatpages.dtx}
\addtolength\signaturewidth{42pt}
\makesignature
\end{document}
%</driver>
%
% \fi
%
%
% \title{The \texttt{lessfloatpages} package\thanks{The current
%   package version is \texttt{\lessfloatpagesversion} dated
%   \lessfloatpagesdate.}}
% \author{Frank Mittelbach}
%
% \maketitle
%
%
% \begin{abstract}
%
%   \LaTeX{}'s float algorithm has the tendency to produce fairly
%   empty float pages, i.e., pages containing only floats but with a
%   lot of free space remaining to could easily be filled with nearby
%   text. There are good reasons for this behavior\Dash nevertheless the
%   results look unappealing and in many cases documents are
%   unnecessarily enlarged.
%
%   the \pkg{lessfloatpages} package provides an extended algorithm
%   that improves on this without the need for manual interventions by
%   the user.
%
% \end{abstract}
%
% \tableofcontents
%
%
%
% \section{Introduction}
%
% \subsection{A quick overview of \LaTeX's float algorithm}
%
%   \LaTeX{}'s output routine uses a greedy algorithm to place floats
%   near to their appearance in the source document. The decision how
%   to place a float is made when the float is first encountered. If
%   possible it is placed onto the current page, either in mid-text,
%   on top or into the bottom area, depending on what is allowed for
%   the float and how many floats are already placed into those
%   areas. 
%
%   If the float can't be placed immediately it goes into a defer list
%   and in order to not accumulate too many unplaced floats \LaTeX{}
%   tries to empty that list whenever the is a chance. This chance
%   comes after the next page break: \LaTeX{} then start a special
%   ``float page'' algorithm  in which it examines the defer list and
%   forms float pages (i.e., pages that only contain floats) from
%   it. If necessary, it generates several  float pages and only stops
%   if there are no floats waiting to be placed or there are too few
%   floats to form a float page or there are only floats left that are
%   for one or the other reason not allowed to be placed in this way.
%
%   Finally \LaTeX{} looks at the remaining floats and tries to place
%   as many of them as possible into the top and bottom area of the
%   next page. Then it continues to process further text to fill the
%   text part of that page. Details on the exact behavior of the
%   algorithm are discussed in \cite{fmi:floatplacement}.
%
%
% \subsection{The typical float page and its problems}
%
%   \LaTeX{} considers a float page to be successfully build if its
%   floats take up more than \cs{floatpagefraction} of the whole
%   page. By default this parameter is set to \texttt{.5} which means
%   that such float pages may end up being nearly half empty.
%
%   Many users think that this not a good value and try to improve on
%   it by enforcing a higher percentage (such as 80\%) only to find
%   that this prevents \LaTeX{} in many cases from successfully
%   generating any float page, with the effect of all floats are
%   suddenly piling up at the end of the document.
%
%   Why is this the case? In a nutshell, because a higher percentage
%   makes it much more likely that there is a float that can't be
%   placed, because by itself it is not big enough to be used on its
%   own and there are no other floats nearby that can be combined with
%   it, because their combination violates some other restriction,
%   e.g., together they are bigger than a page, not all of them are
%   allowed to go on float pages, etc. The moment that happens this
%   floats prevents the placement of all other floats of the same
%   class too (i.e., all figures) and disaster is ensured. In most
%   cases these floats will then never get placed, because they need a
%   float of the right size from a different class to appear, which
%   may in theory happen but is, unfortunately, unlikely.
%
%   Thus, while tempting, tinkering with this parameter by making it
%   larger is usually not a good idea, unless you are prepared to place
%   most if not all of your floats manually, by overwriting the
%   placement algorithm on the level of individual floats (e.g., using
%   \texttt{!}\@ syntax and/or shifting its position in the source
%   document).
%
%
% \section{Improvements to the float page algorithm}
%
%   A possible way to improve on the the existing algorithm, without
%   compromising its main goal of placing the floats as fast as
%   possible and as close as possible to their call-outs, is the
%   following: as long as there are many floats waiting to be placed
%   generate float pages as necessary to get them placed (using the
%   current algorithm and its parameters). However, once we are unable
%   to build further float places, do some level of backtracking by
%   checking if we have actually succeeded in placing all floats.
%
%   If there are still floats waiting to be placed then assume that
%   what as been done so far is the best possible way to place as many
%   floats as possible (which it probably is). However, if we have
%   been able to place all floats onto float pages then check if the
%   last float page is sufficiently full and if not undo the it and
%   instead redistribute its floats into the top and bottom area of
%   the next upcoming page. This way the floats will be combined with
%   further text and we avoid a possible half-empty float page.
%
%   This approach will not resolve all kind problematical scenarios
%   where we find that \LaTeX{} has decided to favor fairly empty
%   float pages over some tighter type of placement. It will, however,
%   help to improve typical cases that do not involve too many floats.
%   For\mnote{A typical case where we don't really want \LaTeX{} to
%   make a float page} a example, if a single (larger) float appears
%   near the end of a page, then using the standard algorithm it can't
%   be immediately placed (since there isn't enough free space on the
%   current page). It is therefore moved to the defer list and at the
%   page break it is then placed onto a float page (possibly by its
%   own, if it is large enough to allow for that) even though it could
%   perfectly well go into the top or bottom area of the next page and
%   thus be combined with textual material on that page.
%
%   With the new algorithm this float page is reexamined and unless it
%   is pretty much filled up already, it is unraveled and its floats
%   are redistributed into the top and bottom areas of the next page.
%   If, however, we have many floats waiting on the defer list, the
%   normal float page algorithm will first place as many of them as
%   possible into float pages and only the last of these pages will be
%   subject to a closer inspection and a possible unraveling.
%
% \subsection{Details on the extended algorithm}
%
%   The main idea of the extended algorithm is to avoid unnecessary cases of
%   float pages especially if those float pages are fairly
%   empty.\mnote{Don't unravel a float page if there are too many
%    floats on the defer list}
%   Natural candidates are single float pages, but even in cases where
%   the current \LaTeX{} algorithm  produces several a sequence float
%   pages the extended algorithm may decide to replace them by normal
%   pages under certain conditions.
%   However, the main goal
%   is and should remain to place as many floats as soon as possible
%   and so generating float pages when many floats are waiting is
%   usually essential.
%
%   \DescribeMacro{floatpagedeferlimit}
% ^^A
%   Whether or not unraveling for a float page is considered at all,
%   is guided by the counter \ctr{floatpagedeferlimit} and as long as
%   there are more floats waiting on the defer list than this number,
%   float pages are not considered for unraveling.  The default is
%   \texttt{3} which corresponds to the default value for
%   \ctr{totalnumber}, i.e., with that setting the unraveling a
%   floating page has a fighting chance to place all floats into the
%   top and bottom areas on the current page.
%   It would also resolve cases such as up to three floats, each larger than
%   \cs{floatepagefraction}, where standard \LaTeX{} algorithm would
%   produce three individual float pages.
%
%   If you set the counter to \texttt{1} then only the last float page
%   in a sequence is considered and only if it contains only a single
%   float and if there are no other floats that are still waiting to
%   be placed.  If you set it to \texttt{0}, then the extension
%   is disabled since float pages are only produced if there was at
%   least one float on the defer list.
%
%   \DescribeMacro{floatpagekeeplimit}
% ^^A
%   Even if we set \ctr{floatpagedeferlimit} to a fairly high value,
%   we may not want to unravel float pages that contain many
%   floats. To support this case there is a second counter that guides the
%   algorithm in this respect. Whenever\mnote{Don't unravel if the float page contains many
%   floats} the float page contains at least
%   \ctr{floatpagekeeplimit} floats it will not be unraveled. The
%   default is also \texttt{3} so that float pages with three or more
%   floats are not touched. Obviously the counter can have only any
%   effect if it has a value less or equal to
%   \ctr{floatpagedeferlimit} since this is tested first.
%
%   There are, however, a number of other situations in which we
%   shouldn't unravel a float page even if the above check for the
%   size of the defer list was passed successfully.\mnote{Don't
%   unravel if the float page contains at least one \texttt{\upshape
%   [p]} float} The most important one is the case when it contains at
%   least one float that is \emph{only} allowed on float pages (i.e.,
%   has a \texttt{[p]} argument). Since such a float would not be
%   placeable in a top/bottom area on any page and thus would be send
%   back to the defer list.
%
%   The other case where unraveling would normally be
%   counterproductive is when the particular float page is nearly or
%   completely filled up with floats.\mnote{Don't unravel if the float
%   page is nearly filled} If we would unravel it, then it is certain
%   that we can only place some of the floats into the top or bottom
%   area of the next page and some would end up on the
%   defer list. That in turn means that these deferred floats float
%   even further away from their call-out positions than they have to
%   be.
%
%   \DescribeMacro\floatpagekeepfraction
% ^^A
%   So what is a good way to determine if a float page is ``full
%   enough''?  A possible answer is that if the remaining free space
%   on that page is less than \cs{textfraction} we consider it full
%   enough to stay. \cs{textfraction} defines the minimum amount of
%   space that has to be occupied by text on a normal page, thus if
%   all floats together need so much space that this amount of text
%   could not be fitted in, then trying to place all floats onto a
%   normal page can't succeed and some of them would get deferred for
%   sure.  To allow for some further flexibility the algorithm uses
%   the variable \cs{floatpagekeepfraction} (defaulting to
%   \cs{textfraction}) so if desired a lower (or even a higher)
%   boundary can be set.
%
%   The above parameters give some reasonable configuration
%   possibilities to guide the algorithm when and when not to unravel
%   a possible float page and instead produce further normal pages.
%   It should be noted, however, that except for the case of setting
%   \ctr{floatpagedeferlimit} to \texttt{1}, there is always a chance
%   that floats drift further away from their call-outs, because the
%   may not be immediately placeable due to other parameter settings
%   of the float algorithm.  For example, the counter
%   \texttt{topnumber} (default value 2) limits the number of floats
%   that can be placed in the top area on a normal page and if more
%   remain after unraveling only two can immediately go in this area.
%
%
% \subsection{Possible pitfalls and how to avoid them}
%
%   The algorithm detects if a float is only allowed on float pages
%   (i.e., is given in the source as \texttt{[p]} and it will ensure
%   that float pages containing such floats are not unraveled.
%
%   However, if you have a float with the default specifier
%   \texttt{[tbp]} whose size is larger than the allowed size of the
%   top or bottom area (e.g., larger than \cs{topfraction}
%   \texttimes{} \cs{textheight}), then this effectively means it can
%   only be placed on float pages.
%
%   However, according to the specifier the float is allowed in to go
%   into the top or bottom area, so the algorithm as explained so far
%   would be allowed to unravel and when that float later is
%   considered for top or bottom placement it will get again deferred and
%   thus move from one page to the next, most likely messing up the
%   whole float placement.
%
%   There\mnote{\option{checktb} (option)} are two possible ways how
%   the algorithm could be improved to avoid this disaster. One way
%   would be to check the float size when it is initially encountered
%   and and removed any specifiers that are technically not possible
%   because of the parameter settings and the float size. The
%   disadvantage of this approach that we will get more floats that
%   have only a \texttt{p} specifier, i.e., that will be more float
%   pages in the end.
%   If you prefer the first approach
%   specify the option \option{checktb}.
%
%   Another\mnote{Default action is to add \texttt{!}\@ specifiers
%   during unraveling} possibility is that we automatically add a
%   \texttt{!}\@  specifier to all floats during unraveling, i.e., when
%   we send them back for reevaluation This way such floats become
%   placeable into top and bottom areas regardless of their size. This
%   is the default action that the algorithm uses if no option is
%   specified.
%
%   If\mnote{\option{nobang} (option)} you prefer neither automatic
%   specifier change add the option \option{nobang}.
%
%   In this case you might find floats of certain sizes to be
%   unplaceable and thus getting delayed to the end of the document.
%   If that happens the remedy is to either explicitly specify
%   \texttt{[p]} for such a float (to ensure that they aren't subject
%   to unraveling) or to manually add an exclamation specifier, e.g.,
%   \texttt{[!tp]} so that \LaTeX{} doesn't use the size restrictions
%   in its algorithm.
%
%
%
% \subsection{Tracing the algorithm}
%
%   The\mnote{\option{trace} (option)} package offers the option
%   \option{trace}, which if used, will result in messages such as
%\begin{verbatim}
%  [1]
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@B \bx@D 
%  lessfloatpages:  starting with \bx@B
%  lessfloatpages:  --> success:  \bx@B \bx@D 
%  lessfloatpages: ----- current float page unraveled
%                  (free space 192.50336pt > 109.99832pt)
%  [2]
%\end{verbatim}
%   which means that the algorithm is trying to make a float page from
%   the defer list which at that point contained two floats (the float
%   boxes \cs{bx@B} and \cs{bx@D}), that it was able to produce a
%   float page just containing  \cs{bx@D} and that the extended algorithm then
%   decided to unravel that float page, because it has an unused
%   space of \texttt{192.5pt} and with the current
%   \cs{floatpagekeepfraction} that is too much.
%
%   Or it might say
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@D \bx@F \bx@G \bx@H \bx@I 
%  lessfloatpages:  starting with \bx@D
%  lessfloatpages:  --> success: \bx@D \bx@F 
%  lessfloatpages: ----- too many deferred floats for unraveling (5 > 3)
%  [3]
%\end{verbatim}
%   which means that the algorithm made a float page out of the first
%   two floats from the defer list (i.e., 3 remained).
%   That
%   page was kept regardless of the amount of free space it contained
%   because we have a total of 5 floats on the defer list and the
%   counter \ctr{floatpagedeferlimit} has its default values o \texttt{3}.
%
%   The above message examples are actually from the same test
%   document. What they also show (implicitly) is that the unraveling
%   that happened after page~1 resulted in only one float (\cs{bx@B})
%   being placed on page~2, because we see the second one (\cs{bx@D})
%   reappearing in the defer list after page~2 got finished. In other
%   words it was moved one page further away from its call-out: the
%   price for getting a nicely filled page~2 instead of a fairly empty
%   float page with roughly 200 points left free (i.e., about 16 lines
%   of normal text).
%   The final part of that test document then exhibits another
%   type of message:
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@G \bx@H \bx@I 
%  lessfloatpages:  starting with \bx@G
%  lessfloatpages:  --> success: \bx@G \bx@H \bx@I 
%  lessfloatpages: ----- all floats placed on float page(s)
%  lessfloatpages: ----- current float page kept, full enough
%                        (free space 38.99496pt < 109.99832pt)
%  [4]
%\end{verbatim}
%   This means that the remaining floats (that were left unplaced
%   after float page~3 got constructed) by themselves formed a float
%   page and that float page was the last in sequence (i.e., all
%   floats have been placed). However, this time the algorithm decided not
%   to unravel it, because it is nicely full: there are only 39 points
%   of free space left on that page.
%
%   Three other possible messages are shown in this sequence of
%   typeouts from a second test document (which is using some uncommon
%   settings (\ctr{floatpagedeferlimit} is \texttt{10} and
%   \ctr{floatpagekeeplimit} is \texttt{5}):
%\begin{verbatim}
%  [1]
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@B \bx@C \bx@D \bx@E \bx@F \bx@G \bx@H 
%  lessfloatpages:  starting with \bx@B
%  lessfloatpages:  --> success: \bx@B \bx@C \bx@D \bx@E \bx@F \bx@G \bx@H 
%  lessfloatpages: ----- current float page kept (contains at least 5 floats)
%  [2] [3]
%\end{verbatim}
%   In this case 7 floats have been waiting on the defer list and the
%   algorithm was able to construct a float page using all of them.
%   The algorithm then keeps that page because it has 5 or more floats
%   in it (the value of the\ctr{floatpagekeeplimit} counter).
%
%   The next message in that test document then shows what happens
%   when there are not enough floats waiting or they are simply too
%   small (to even surpass \cs{floatpagefraction}):
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@I \bx@J 
%  lessfloatpages:  starting with \bx@I
%  lessfloatpages:  --> fail
%  lessfloatpages:  starting with \bx@J
%  lessfloatpages:  --> fail
%  lessfloatpages:  --> fail: no float page made
%  [4]
%\end{verbatim}
%   So no float page was made, but for some reason (that becomes clear
%   later) the two floats also didn't got distributed into the top or
%   bottom area of the next page. Instead they remained on the
%   defer list and during processing of page~4 one more float was
%   found so that after that page the defer list had grown to
%   length~3:
%
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@I \bx@J \bx@K 
%  lessfloatpages:  starting with \bx@I
%  lessfloatpages:  --> success: \bx@I \bx@J \bx@K 
%  lessfloatpages: ----- current float page kept, contains a [p] float
%  [5]
%\end{verbatim}
%   This time all floats could be placed, but again the float page
%   wasn't unraveled (even though in the test document it contained a
%   lot of white space) because of the fact that one of its floats (in fact
%   the first though that can only be deduced implicitly) was
%   specified as a \enquote{float page only} float. This explains why
%   on page~4 \cs{bx@I} couldn't be placed into the top or bottom
%   area and then all following floats of the same class (the test
%   document only contained \env{figure} floats) couldn't be placed
%   either.
%
%   If\mnote{Detailed tracing of the complete algorithm} you want
%   detailed tracing of the complete algorithm, also load the
%   \pkg{fltrace} package and enable the tracing with
%   \cs{tracefloats} anywhere in your document. Note, however, that
%   the resulting output is very detailed but rather low-level and
%   unpolished.
%
%
%
%
%
% \subsection{Local adjustments}
%
%   If the extended algorithm is used you will get less float pages
%   that contain a noticeable amount of white space. By adjusting
%   \cs{floatpagekeepfraction} and the counters \ctr{floatpagekeeplimit} and
%   \ctr{floatpagedeferlimit} you can direct the algorithm to unravel more or
%   less of the otherwise generate float pages. However, in some cases
%   it might happen that redistribution of the floats into the top and
%   bottom areas of the next page(s) may result in some of them
%   drifting too far away from their call-outs. If that happen you can
%   either try to change the general parameters or you could help the
%   algorithm along by using the optional argument of individual float
%   environments.
%   The two main tools at your disposal are
%   \begin{itemize}
%   \item
%     using the \texttt{[!..]} notation to allow the float to go into
%     the top or bottom area even if it would be normally prevented by
%     other restrictions;
%   \item
%     using \texttt{[p]} to force a float into a float page as that
%     prevents the algorithm to unravel the float page which contains
%     that float.
%   \end{itemize}
%   As an alternative you can, of course, temporarily alter the
%   definition of the command \cs{floatpagekeepfraction} or the values
%   of two counters in mid-document, but remember that they are not
%   looked at when a float is encountered in the source but when we are
%   at a page break and \LaTeX{} attempts to empty the defer list,
%   which is usually later and unfortunately somewhat asynchronous,
%   i.e., not easy to predict.
%
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex  }
%
%
% \section{The Implementation}
%
%    We start off with package announcement. Requiring a fairly new
%    \LaTeX{} kernel is not absolutely necessary but it will help to
%    ensure that we patch what we think we patch and in the future it
%    means that will can be assured that the rollback functionality of
%    the kernel is available in case will need to support several
%    releases of the package.
%    \begin{macrocode}
%<*package>
\NeedsTeXFormat{LaTeX2e}[2018-04-01]
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesPackage{lessfloatpages}
                [\lessfloatpagesdate\space
                 \lessfloatpagesversion\space
                 improve float page generation (FMi)]
%    \end{macrocode}
%
% \subsection{Option handling}
%                
%    This release of the package has three options: \option{trace}
%    for tracing the algorithm and \option{nobang} and
%    \option{checktb} to handle cases where the float size in
%    combination with the float specifiers makes it difficult if not
%    impossible to places the floats.
%                
%    The option \option{trace} enables tracing of the algorithm and is
%    implemented by giving the command \cs{fl@trace} (which is also
%    used by the \pkg{fltrace} package) a suitable definition.
%
%    To cater for the case that the \pkg{fltrace} package is loaded
%    first, we use \cs{providecommand}, so that its definition is not
%    overwritten, but used if it is already in available. If the package is
%    loaded later everything works fine because it unconditionally
%    defines \cs{fl@trace}, i.e., overwrites whatever
%   \pkg{lessfloatpages} has defined.
%
%    \begin{macrocode}
\DeclareOption{trace}
              {\providecommand\fl@trace[1]%
                {{\let\@elt\@empty\typeout{lessfloatpages: #1}}}}
%    \end{macrocode}
%
%    By default the algorithm adds a \texttt{!}\@ to floats that are
%    send back for reevaluation when a float pages gets
%    unraveled. With \option{nobang} this action is suppressed at the
%    cost that some floats may float to the end of the document.
%    \begin{macrocode}
\DeclareOption{nobang}
              {\let\fp@maybe@add@bang\@gobble}
%    \end{macrocode}
%    
%    Option \option{checktb} implements a different approach to
%    handling problematic floats. If used the vertical size of a float
%    is checked and if it is too large to be allowed into the top or
%    the bottom area any \texttt{t} or \texttt{b} specifier is
%    replaced by \texttt{p} (or dropped if \texttt{p} is already
%    specified). This option implies \option{nobang}.
%    \begin{macrocode}
\DeclareOption{checktb}
              {\let\fp@maybe@checktb\relax
               \let\fp@maybe@add@bang\@gobble}
\ProcessOptions
%    \end{macrocode}
%
%
% \subsection{Tracing code}
%                
%  \begin{macro}[internal]{fl@trace}
%    The command \cs{fl@trace} is used to output tracing information.
%    By default the tracing of the algorithm is turned off, so
%    \cs{fl@trace} will simply swallow its argument. But if
%    \pkg{fltrace} is loaded or the option \option{trace} is given
%    then the command already has a definition so we don't change it
%    here.
%    \begin{macrocode}
\providecommand\fl@trace[1]{}
%    \end{macrocode}
%  \end{macro}
%
%
% \subsection{User-level interfaces}
%
%    For the most part the packages provides internal code that
%    extends the float algorithm of \LaTeX{}. There are, however, also
%    three new parameters the guide this algorithm, they are defined
%    in this section.
%
%  \begin{macro}[var]{\floatpagekeepfraction}
%    The fraction that the algorithm uses to decide that a given float
%    page is so full that it would be pointless to unravel it for the
%    reasons outlined above. The default is whatever fraction has been
%    chosen as the minim amount of text that need to be on a normal
%    page (i.e., \cs{textfraction}).
%    \begin{macrocode}
\newcommand\floatpagekeepfraction{\textfraction}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}[var]{\c@floatpagedeferlimit}

%    The algorithm will only consider unraveling float pages if are
%    aren't too many floats on the defer list. The definition of
%    \enquote{too many} is given by the counter
%    \ctr{floatpagedeferlimit} if there are more floats waiting to be
%    placed, float pages are generated until their number falls below
%    this level. Thus, a value of \texttt{0} will disable the whole
%    algorithm and a value of \texttt{1} means that only float pages
%    with a single float might get unraveled and only if there aren't
%    others still waiting to be placed.
%    \begin{macrocode}
\newcounter{floatpagedeferlimit}
\setcounter{floatpagedeferlimit}{3}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}[var]{\c@floatpagekeeplimit}
%
%    A float page that contains at least this number of floats will
%    also be kept. The default is \texttt{3} but if you have a lot of
%    small floats it might be better to set this to a higher
%    value.
%    \begin{macrocode}
\newcounter{floatpagekeeplimit}
\setcounter{floatpagekeeplimit}{3}
%    \end{macrocode}
%  \end{macro}





% \subsection{Patching the \LaTeX{} kernel commands}
%                


%
%  \begin{macro}[internal]{\@tryfcolumn}
%    The main macro we have to patch to extend \LaTeX's algorithm is
%    \cs{@tryfcolumn}. That command is changed when \pkg{fltrace}
%    gets loaded, so we make our definition as late as possible to
%    ensure that it will survive.
%    \begin{macrocode}
\AtBeginDocument{%
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \@tryfcolumn #1{%
  \global \@fcolmadefalse
  \ifx #1\@empty
  \else
    \fl@trace{PAGE: trying to make a float
                    \if@twocolumn column/page\else page\fi}%
    \fl@trace{----- \string #1: #1}%
    \xdef\@trylist{#1}%
    \global \let \@failedlist \@empty
    \begingroup
      \let \@elt \@xtryfc \@trylist
    \endgroup
%    \end{macrocode}
%    Up to this point the definition is the same as in the original
%    algorithm. At this point the  switch \cs{if@fcolmade}  tells us if making a
%    float page was successful and the original algorithm then called
%    \cs{@vtryfc} and removed the floats used for this float page from the defer list.
%
%    In the extended algorithm this is the place where things start to
%    differ as we may not want that float page to actually come into
%    existence.
%    \begin{macrocode}
    \if@fcolmade
%    \end{macrocode}
%    As a first step we count the number of floats in the defer list
%    and save the result in \cs{fp@candidates}.
%    \begin{macrocode}
      \fp@candidates\z@
      \def\@elt##1{\advance\fp@candidates\@ne}%
        #1%
      \let\@elt\relax
%    \end{macrocode}
%    Now we compare this number with the values of the counter \ctr{floatpagedeferlimit}
%    and if it is higher we definitely want to keep the float
%    page. The rationale is that if we unravel that all floats from
%    the defer list need to go into the top/bottom areas (or get
%    deferred again) and so a high number means the defer list will
%    not get shortened very much and too many floats will get delayed further.
%    \begin{macrocode}
      \ifnum \fp@candidates >\c@floatpagedeferlimit
        \fl@trace{----- too many deferred floats for unraveling
                   (\the\fp@candidates\space> \the\c@floatpagedeferlimit)}%
      \else
%    \end{macrocode}
%
%    Otherwise we do a bit more testing. First we set \cs{if@fcolmade}
%    back to false, after all our goal is to not  keep the float page. If
%    during the tests we decide otherwise we set it back to true which
%    then signals that it should stay.
%
%    We also count the floats on the float page and use \cs{count@}
%    for that which us why we initialize it to zero.
%    \begin{macrocode}
        \global \@fcolmadefalse
        \count@\z@
%    \end{macrocode}
%    The actually checking is done with
%    \cs{analyse@floats@for@unraveling} and it loops over
%    \cs{@flsucceed}, i.e., the floats for that float page. This
%    checks if any float has only a \texttt{[p]} specifier and if so
%    sets \cs{if@fcolmade} back to \texttt{true} and as a side effect also does
%    the counting for us.
%    \begin{macrocode}
        \let\@elt\analyse@floats@for@unraveling
          \@flsucceed
        \let\@elt\relax
%    \end{macrocode}
%    Now we recheck the state of the switch and if it still says
%    \texttt{false} all tests indicated that we don't want the float
%    page.
%    \begin{macrocode}
        \if@fcolmade
        \else
%    \end{macrocode}
%    But we aren't done yet: the float page might be nicely filled,
%    which case it would be a shame to unravel it. During the above
%    loop we also measured the free space on the float page and stored
%    it in \cs{fp@unused@space}. We now compare that to the maximum
%    free space that we consider to be still okay and if there is more
%    we finally do the unraveling.
%    \begin{macrocode}
          \@tempdima\floatpagekeepfraction\@colht
          \ifdim \fp@unused@space >\@tempdima
            \fl@trace{----- current float page unraveled^^J%
                      \@spaces\@spaces\@spaces\space\space\space
                      (free space \fp@unused@space\space > \the\@tempdima)}%
%    \end{macrocode}
%    For this be basically return all floats back to the
%    defer list. The switch is still \texttt{false} so it doesn't need
%    changing.
%    \begin{macrocode}
            \xdef #1{\@failedlist\@flsucceed\@flfail}%
%    \end{macrocode}
%    However, we also want to add a \texttt{!}\@ specifier to each of
%    the floats (unless the user specified the \option{nobang} option)
%    so we loop over all the floats once more to get this
%    done.\footnote{This could have been integrated with
%    \cs{analyse@floats@for@unraveling} but there is not much gain if
%    any and this way the prcessing logic seems clearer to me.}
%    \begin{macrocode}
            \let\@elt\fp@maybe@add@bang
              \@flsucceed
            \let\@elt\relax
          \else
%    \end{macrocode}
%    But if we want to keep the float page after all, we have to set
%    the switch back to \texttt{true} so that the rest of the
%    algorithm proceeds correctly.
%    \begin{macrocode}
            \global \@fcolmadetrue
            \fl@trace{----- current float page kept, full enough^^J%
                      \@spaces\@spaces\@spaces\space\space\space
                      (free space \fp@unused@space\space < \the\@tempdima)}%
          \fi
        \fi
      \fi
%    \end{macrocode}
%    The next \cs{else} matches the first \cs{if@fcolmade}, i.e., the
%    case that the algorithm wasn't able to make any float page and if
%    we are tracing the algorithm, we want to tell the user about this.
%    \begin{macrocode}
    \else
      \fl@trace{ --> fail: no float page made}%
    \fi
%    \end{macrocode}
%    
%    Finally, at this point we are back in the original algorithm. Now the
%    switch tells the truth about whether or not we want to make a float
%    page and if so we go ahead and produce it.
%    \begin{macrocode}
    \if@fcolmade
        \@vtryfc #1%
    \fi
  \fi
}%
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}[internal]{\@makefcolumn}
%
%    In contrast to \cs{@tryfcolumn} this macro will always make float
%    pages out of the deferred floats. It is used by \cs{clearpage}
%    when we really need the floats to get out and there is no further
%    text coming up. Thus, in that case we should not unravel the float
%    pages which would happen if we use the kernel definition of \cs{@makefcolumn}.
%
%
%    Again we make this change at \verb=\begin{document}= so
%    that we replace any change done by \pkg{fltrace}.
%    \begin{macrocode}
\def\@makefcolumn #1{%
  \begingroup
    \@fpmin -\maxdimen
    \let \@testfp \@gobble
%    \end{macrocode}
%    At this point the original definition called \cs{@tryfcolumn} and
%    the lines above ensured that it was always succeeding in making
%    a float page. Since we have changed that command to do unraveling
%    we better not use it. Instead we replace it by its original
%    definition (with the addition of two tracing lines).
%    \begin{macrocode}
    \global \@fcolmadefalse
    \ifx #1\@empty
    \else
      \fl@trace{PAGE: trying to make a float
                      \if@twocolumn column/page\else page\fi}%
      \fl@trace{----- \string #1: #1}%
      \xdef\@trylist{#1}%
      \global \let \@failedlist \@empty
      \begingroup
	\let \@elt \@xtryfc \@trylist
      \endgroup
      \if@fcolmade
	\@vtryfc #1%
      \fi
    \fi
  \endgroup
}%
}             % -- END \AtBeginDocument
%    \end{macrocode}
%  \end{macro}





% \subsection{Aux helpers}
%                
%
%  \begin{macro}[internal]{fp@candidates}
%    We use an internal counter to count the number of floats in the defer list.
%    \begin{macrocode}
\newcount\fp@candidates
%    \end{macrocode}
%  \end{macro}




%  \begin{macro}[internal]{\fp@unused@space}
%    
%    \begin{macrocode}
\def\fp@unused@space{}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}[internal]{\@ytryfc}
%    
%    \begin{macrocode}
\def\@ytryfc #1{%
  \begingroup
    \gdef\@flsucceed{\@elt #1}%
    \global\let\@flfail\@empty
    \@tempdima\ht #1%
    \let\@elt\@ztryfc
    \@trylist
    \ifdim \@tempdima >\@fpmin
      \global\@fcolmadetrue
%    \end{macrocode}
%    
%    \begin{macrocode}
      \@tempdimb\@colht
      \advance\@tempdimb-\@tempdima
      \xdef\fp@unused@space{\the\@tempdimb}%
%    \end{macrocode}
%    
%    \begin{macrocode}
    \else
      \@cons\@failedlist #1%
      \fl@trace{ --> fail}%
    \fi
  \endgroup
  \if@fcolmade
    \let\@elt\@gobble
    \fl@trace{ --> success: \@flsucceed}%
  \fi}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}[internal]{\analyse@floats@for@unraveling}
%    
%    \begin{macrocode}
\def\analyse@floats@for@unraveling#1{%
  \advance\count@\@ne
  \ifnum \count@ <\c@floatpagekeeplimit
    \@tempcntb\count#1%
    \divide\@tempcntb 8\relax
    \multiply\@tempcntb 8\relax
%
    \ifnum \count#1=\@tempcntb
      \global \@fcolmadetrue
      \let\@elt\@gobble
    \fl@trace{----- current float page kept, contains a [p] float}%
    \fi
  \else
    \global \@fcolmadetrue
    \let\@elt\@gobble
    \fl@trace{----- current float page kept (contains at least
       \the\count@\space floats)}%
  \fi
%
}
%    \end{macrocode}
%  \end{macro}
%

%  \begin{macro}[internal]{\fp@maybe@add@bang}
%    
%    \begin{macrocode}
\ifx\fp@maybe@add@bang\@undefined
\def\fp@maybe@add@bang#1{%
  \@boxfpsbit #1\sixt@@n
  \ifodd \@tempcnta
    \global\advance\count#1-\sixt@@n
  \fi
}
\fi
%    \end{macrocode}
%  \end{macro}
%



%  \begin{macro}[internal]{\@largefloatcheck}
%    
%    \begin{macrocode}
\def \@largefloatcheck{%
  \ifdim \ht\@currbox>\textheight
    \@tempdima -\textheight
    \advance \@tempdima \ht\@currbox
    \@latex@warning {Float too large for page by \the\@tempdima}%
    \ht\@currbox \textheight
  \fi    
%    \end{macrocode}
%    
%    \begin{macrocode}
  \fp@maybe@checktb
}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}[internal]{\fp@maybe@checktb}
%    
%    \begin{macrocode}
\ifx\fp@maybe@checktb\@undefined
  \let\fp@maybe@checktb\relax
\else
  \def\fp@maybe@checktb{%
    \@getfpsbit \sixt@@n
    \ifodd \@tempcnta
      \ifdim \ht\@currbox>\topfraction\textheight
	\@getfpsbit \tw@
	\ifodd \@tempcnta
	  \global\advance\count\@currbox -\tw@
	  \fp@add@p@bit
	  \@latex@warning {Float too large for top area: t changed to p}%
	\fi
      \fi
      \ifdim \ht\@currbox>\bottomfraction\textheight
	\@getfpsbit 4\relax
	\ifodd \@tempcnta 
	  \global\advance\count\@currbox -4\relax
	  \fp@add@p@bit
	  \@latex@warning {Float too large for bottom area:
			   b changed to p}%
	\fi
      \fi
    \fi
  }
\fi  
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\fp@add@p@bit}
%    
%    \begin{macrocode}
\def\fp@add@p@bit{%
   \@getfpsbit 8\relax
   \ifodd \@tempcnta
   \else
     \global\advance\count\@currbox 8\relax
   \fi
}
%    \end{macrocode}
%  \end{macro}



% \subsection{Updates that will go into \pkg{fltrace} eventually}

%  \begin{macro}{\@xtryfc}
%    The only change here is the addition of the \cs{fl@trace} info.
%    \begin{macrocode}
\def\@xtryfc #1{%
  \fl@trace{ starting with \string#1}%
  \@next\reserved@a\@trylist{}{}%
  \@currtype \count #1%
  \divide\@currtype\@xxxii
  \multiply\@currtype\@xxxii
  \@bitor \@currtype \@failedlist
  \@testfp #1%
  \@testwrongwidth #1%
  \ifdim \ht #1>\@colht
     \@testtrue
  \fi
  \if@test
    \@cons\@failedlist #1%
    \fl@trace{ --> fail}%
  \else
    \@ytryfc #1%
  \fi
}%
%    \end{macrocode}
%  \end{macro}




%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% \Finale
%


