% \iffalse meta-comment
%
%% File: lessfloatpages.dtx (C) Copyright 2019 Frank Mittelbach
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
%
% The development version of the bundle can be found below
%
%    https://github.com/FrankMittelbach/fmitex/
%
% for those people who are interested or want to report an issue.
%
%<*driver>
\documentclass{l3doc}

\newcommand\ctr[1]{\texttt{#1}}
\newcommand\mnote[1]{\marginpar{\raggedleft\em #1}}

\usepackage{csquotes,lessfloatpages}
\EnableCrossrefs
\CodelineIndex
\begin{document}
  \DocInput{lessfloatpages.dtx}
\end{document}
%</driver>
%
% \fi
%
%
% \title{The \texttt{lessfloatpages} package\thanks{}}
% \author{Frank Mittelbach}
%
% \maketitle
%
%
% \begin{abstract}
%
%   \LaTeX{}'s float algorithm has the tendency to produce fairly
%   empty float pages, i.e., pages containing only floats but with a
%   lot of free space remaining to could easily be filled with nearby
%   text. There are good reasons for this behavior, nevertheless the
%   results look unappealing and in many cases documents are
%   unnecessarily enlarged.
%
%   the \pkg{lessfloatpages} package provides an extended algorithm
%   that improves on this without the need for manual interventions by
%   the user.
%
% \end{abstract}
%
% \tableofcontents
%
%
%
% \section{Introduction}
%
% \subsection{A quick overview of \LaTeX's float algorithm}
%
%   \LaTeX{}'s output routine uses a greedy algorithm to place floats
%   near to their appearance in the source document. The decision how
%   to place a float is made when the float is first encountered. If
%   possible it is placed onto the current page, either in mid-text,
%   on top or into the bottom area, depending on what is allowed for
%   the float and how many floats are already placed into those
%   areas. 
%
%   If the float can't be placed immediately it goes into a defer-list
%   and in order to not accumulate too many unplaced floats \LaTeX{}
%   tries to empty that list whenever the is a chance. This chance
%   comes after the next page break: \LaTeX{} then start a special
%   ``float page'' algorithm  in which it examines the defer-list and
%   forms float pages (i.e., pages that only contain floats) from
%   it. If necessary, it generates several  float pages and only stops
%   if there are no floats waiting to be placed or there are too few
%   floats to form a float page or there are only floats left that are
%   for one or the other reason not allowed to be placed in this way.
%
%   Finally \LaTeX{} looks at the remaining floats and tries to place
%   as many of them as possible into the top and bottom area of the
%   next page. Then it continues to process further text to fill the
%   text part of that page. Details on the exact behavior of the
%   algorithm are discussed in \cite{fmi:floatplacement}.
%
%
% \subsection{The typical float page and its problems}
%
%   \LaTeX{} considers a float page to be successfully build if its
%   floats take up more than \cs{floatpagefraction} of the whole
%   page. By default this parameter is set to \texttt{.5} which means
%   that such float pages may end up being nearly half empty.
%
%   Many users think that this not a good value and try to improve on
%   it by enforcing a higher percentage (such as 80\%) only to find
%   that this prevents \LaTeX{} in many cases from successfully
%   generating any float page, with the effect of all floats are
%   suddenly piling up at the end of the document.
%
%   Why is this the case? In a nutshell, because a higher percentage
%   makes it much more likely that there is a float that can't be
%   placed, because by itself it is not big enough to be used on its
%   own and there are no other floats nearby that can be combined with
%   it, because their combination violates some other restriction,
%   e.g., together they are bigger than a page, not all of them are
%   allowed to go on float pages, etc. The moment that happens this
%   floats prevents the placement of all other floats of the same
%   class too (i.e., all figures) and disaster is ensured. In most
%   cases these floats will then never get placed, because they need a
%   float of the right size from a different class to appear, which
%   may in theory happen but is, unfortunately, unlikely.
%
%   Thus, while tempting, tinkering with this parameter by making it
%   larger is usually not a good idea, unless you are prepared to place
%   most if not all of your floats manually, by overwriting the
%   placement algorithm on the level of individual floats (e.g., using
%   \texttt{!} syntax and/or shifting its position in the source
%   document).
%
%
% \section{Improvements to the float page algorithm}
%
%   A possible way to improve on the the existing algorithm, without
%   compromising its main goal of placing the floats as fast as
%   possible and as close as possible to their call-outs, is the
%   following: as long as there are many floats waiting to be placed
%   generate float pages as necessary to get them placed (using the
%   current algorithm and its parameters). However, once we are unable
%   to build further float places, do some level of backtracking by
%   checking if we have actually succeeded in placing all floats.
%
%   If there are still floats waiting to be placed then assume that
%   what as been done so far is the best possible way to place as many
%   floats as possible (which it probably is). However, if we have
%   been able to place all floats onto float pages then check if the
%   last float page is sufficiently full and if not undo the it and
%   instead redistribute its floats into the top and bottom area of
%   the next upcoming page. This way the floats will be combined with
%   further text and we avoid a possible half-empty float page.
%
%   This approach will not resolve all kind problematical scenarios
%   where we find that \LaTeX{} has decided to favor fairly empty
%   float pages over some tighter type of placement. It will, however,
%   help to improve typical cases that do not involve too many floats.
%   For\mnote{A typical case where we don't really want \LaTeX{} to
%   make a float page} a example, if a single (larger) float appears
%   near the end of a page, then using the standard algorithm it can't
%   be immediately placed (since there isn't enough free space on the
%   current page). It is therefore moved to the defer-list and at the
%   page break it is then placed onto a float page (possibly by its
%   own, if it is large enough to allow for that) even though it could
%   perfectly well go into the top or bottom area of the next page and
%   thus be combined with textual material on that page.
%
%   With the new algorithm this float page is reexamined and unless it
%   is pretty much filled up already, it is unraveled and its floats
%   are redistributed into the top and bottom areas of the next page.
%   If, however, we have many floats waiting on the defer-list, the
%   normal float page algorithm will first place as many of them as
%   possible into float pages and only the last of these pages will be
%   subject to a closer inspection and a possible unraveling.
%
% \subsection{Details on the extended algorithm}
%
%   The main idea of the extended algorithm is to avoid cases of
%   single float pages if those float pages are fairly
%   empty.\mnote{Don't unravel a float page if there are still
%   unplaced floats on the defer-list} More
%   exactly, it will consider unraveling the last float page in a
%   sequence of such pages. Why only the last? Because the main goal
%   is and should remain to place as many floats as soon as possible
%   and so generating float pages when many float are waiting is
%   essential.
%
%   \DescribeMacro{\c@floatpageunplaced}
% ^^A
%   Actually, you can ask the algorithm to unravel float pages even if
%   there are further floats waiting to be placed. This is controlled
%   by the counter \ctr{floatpageunplaced} and as long as there are more
%   floats waiting than this number,  float pages are not considered for
%   unraveling. The default is \texttt{0}, i.e., with that setting
%   only the last float page in sequence is considered and only if
%   the defer-list got completely emptied. If your documents do not
%   contain too many floats then setting this counter to \texttt{1} or
%   \texttt{2} might improve the placement in many cases.
%
%   There are a number of other situations, hoewever, in which we shouldn't
%   unravel a float page.\mnote{Don't unravel if the
%   float page contains at least one \texttt{\upshape [p]} float} The
%   most important one is the case when it contains at least one float
%   that is \emph{only} allowed on float pages (i.e., has a
%   \texttt{[p]} argument). Since such a float would not be placeable
%   in the top/bottom area of the next page it would be send back to
%   the defer-list.
%
%   The other case where unraveling would normally be
%   counterproductive is when the particular float page is completely
%   filled up with floats.\mnote{Don't unravel if the float page is
%   nearly filled} If we would unravel it, then it is certain
%   that we can only place some of the floats into the top or bottom
%   area of the next page and some would end up on the
%   defer-list. That in turn means that these defered floats float
%   even further away from their call-out positions than they have to
%   be.
%
%   \DescribeMacro\floatpagekeepfraction
% ^^A
%   So what is a good way to determine if a float page is ``full
%   enough''?  A possible answer is that if the remaining free space
%   on that page is less than \cs{textfraction} we consider it full
%   enough to stay. \cs{textfraction} defines the minimum amount of
%   space that has to be occupied by text on a normal page, thus if
%   all floats together need so much space that this amount of text
%   could not be fitted in then trying to place the all floats onto a
%   normal page can't succeed and some of them would get deferred for
%   sure.  To allow for some further flexibility the algorithm uses
%   the variable \cs{floatpagekeepfraction} (defaulting to
%   \cs{textfraction}) so if desired a lower (or even a higher)
%   boundary can be set.
%
%   There are, however, other reasons why we might be unable to place
%   all floats of a float page into the top and bottom area of the
%   next page.\mnote{Don't unravel if the float page contains many
%   floats} For example, the counter \texttt{totalnumber} (default
%   value 3) limits the number of floats that can be placed on a
%   normal page, while for float pages there is no such limit.

%   \DescribeMacro{\c@floatpagenumber}
% ^^A
%   To account for this scenario the algorithm offers the counter
%   \ctr{floatpagenumber} and whenever a float page contains more
%   floats than this number, then it is not unraveled either. The
%   default is \texttt{4} (\texttt{totalnumber+1}), i.e., we unravel
%   even if there are too many floats, but only if a few can't be
%   placed (so that chances that they are placed on the page after is
%   very high).
%
% \subsection{Tracing the algorithm}
%
%   The package offers the option \texttt{trace}, which if used, will
%   result in messages such as
%\begin{verbatim}
%  [1]
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@B \bx@D 
%  lessfloatpages:  starting with \bx@B
%  lessfloatpages:  --> success: \bx@B \bx@D 
%  lessfloatpages: ----- all floats placed on float page(s)
%  lessfloatpages: ----- current float page unraveled
%                 (free space 192.50336pt > 109.99832pt)
%  [2]
%\end{verbatim}
%   which means that the algorithm is trying to make a float page from
%   the defer-list which at that point contained two floats (the float
%   boxes \cs{bx@B} and \cs{bx@C}), that it was able to place all
%   floats onto the float page and that the extended algorithm then
%   decided to unravel that last float page, because it has a free
%   space of \texttt{192.5pt} and with the current
%   \cs{floatpagekeepfraction} it is too much.
%
%   Or it might say
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@D \bx@F \bx@G \bx@H \bx@I 
%  lessfloatpages:  starting with \bx@D
%  lessfloatpages:  --> success: \bx@D \bx@F 
%  lessfloatpages: ----- unplaceable floats: \bx@G \bx@H \bx@I 
%  lessfloatpages: ----- too many unplaced floats for unraveling (> 2)
%  [3]
%\end{verbatim}
%   which means that the algorithm made a float page out of the first
%   two floats from the defer-list (i.e., 3 remained) and that the
%   counter \ctr{floatpageunplaced} was changed from its default
%   (\texttt{0}) to \texttt{2} but since that is less than 3, the float
%   page was kept regardless of the amount of free space it contained.
%
%   The above message examples are actually from the same test
%   document. What they also show (implicitly) is that the unraveling
%   that happened after page~1 resulted in only one float (\cs{bx@B})
%   being placed on page~2, because we see the second one (\cs{bx@D})
%   reappearing in the defer-list after page~2 got finished. In other
%   words it was moved one page further away from its call-out: the
%   price for getting a nicely filled page~2 instead of a fairly empty
%   float page with roughly 200 points left free (i.e., about 16 lines
%   of normal text).
%   The final part of that test document then exhibits another
%   type of message:
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@G \bx@H \bx@I 
%  lessfloatpages:  starting with \bx@G
%  lessfloatpages:  --> success: \bx@G \bx@H \bx@I 
%  lessfloatpages: ----- all floats placed on float page(s)
%  lessfloatpages: ----- current float page kept, full enough
%                 (free space 38.99496pt < 109.99832pt)
%  [4]
%\end{verbatim}
%   This means that the remaining floats (that were left unplaced
%   after float page~3 got constructed) by themselves formed a float
%   page and that float page was the last in sequence (i.e., all
%   floats have been placed). However, this time the algorithm decided not
%   to unravel it, because it is nicely full: there are only 39 points
%   of free space left on that page.
%
%   Three other possible messages are shown in this sequence of
%   typeouts from a second test document:
%\begin{verbatim}
%  [1]
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@B \bx@C \bx@D \bx@E \bx@F \bx@G \bx@H 
%  lessfloatpages:  --> success: \bx@B \bx@C \bx@D \bx@E \bx@F \bx@G \bx@H 
%  lessfloatpages: ----- all floats placed on float page(s)
%  lessfloatpages: ----- current float page kept, contains many floats
%                        (at least 5 > 4)
%  [2] [3]
%\end{verbatim}
%   In this case 7 floats have been waiting on the defer-list and the
%   algorithm was able to construct a float page that contained more
%   than 4 floats from it (where 4 is the current value of the
%   \ctr{floatpagenumber} counter). It was actually able to put all
%   seven floats onto that page, which we can deduce from the fact that no
%   further float page attempts were made. However, since 5 is
%   already more than what was allowed for unraveling, the algorithm
%   stopped checking for efficiency reasons.
%
%   The next message in that test document then shows what happens
%   when there are not enough floats waiting or they are simply too
%   small (to even surpass \cs{floatpagefraction}):
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@I \bx@J 
%  lessfloatpages:  starting with \bx@I
%  lessfloatpages:  --> fail
%  lessfloatpages:  starting with \bx@J
%  lessfloatpages:  --> fail
%  lessfloatpages:  --> fail: no float page made
%  [4]
%\end{verbatim}
%   So no float page was made, but for some reason (that becomes clear
%   later) the two floats also didn't got distributed into the top or
%   bottom area of the next page. Instead they remained on the
%   defer-list and during processing of page~4 one more float was
%   found so that after that page the defer-list had grown to
%   length~3:
%
%\begin{verbatim}
%  lessfloatpages: PAGE: trying to make a float page
%  lessfloatpages: ----- \@deferlist: \bx@I \bx@J \bx@K 
%  lessfloatpages:  starting with \bx@I
%  lessfloatpages:  --> success: \bx@I \bx@J \bx@K 
%  lessfloatpages: ----- all floats placed on float page(s)
%  lessfloatpages: ----- current float page kept, contains a [p] float
%  [5]
%\end{verbatim}
%   This time all floats could be placed, but again the float page
%   wasn't raveled (even though in the test document it contained a
%   lot of white space) because of the fact that one of them (in fact
%   the first though that can only be deduced implicitly) was
%   specified as a \enquote{float page only} float. This explains why
%   on page~4 \cs{bx@I} couldn't be placed into the top or bottom
%   area and there all following floats of the same class (the test
%   document only contained \env{figure} floats) couldn't be placed
%   either.
%
%   If\mnote{Detailed tracing of the complete algorithm} you want
%   detailed tracing of the complete algorithm, also load the
%   \pkg{fltrace} package and enable the tracing with
%   \cs{tracefloatson} anywhere in your document. Note, however, that
%   the resulting output is very detailed but rather low-level and
%   unpolished.
%
%
%
%
%
% \subsection{Local adjustments}
%
%   If the extended algorithm is used you will get less float pages
%   that contain a noticeable amount of white space. By adjusting
%   \cs{floatpagekeepfraction} and the counters \ctr{floatpagenumber} and
%   \ctr{floatpageunplaced} direct the algorithm to unravel more or
%   less of the otherwise generate float pages. However, in some cases
%   it might happen that redistribution of the float into the top and
%   bottom areas of the next page(s) may result in some of them
%   drifting too far away from their call-outs. If that happen you can
%   either try to change the general parameters or you could help the
%   algorithm along by using the optional argument of individual floar
%   environments.
%   The two main tools at your disposal are
%   \begin{itemize}
%   \item
%     using the \texttt{[!..]} notation to allow the float to go into
%     the top or bottom area even if it would be normally prevented by
%     other restrictions
%   \item
%     using \texttt{[p]} to force a float into a float page as that
%     prevents the algorithm to unravel the float page which contains
%     that float.
%   \end{itemize}
%   As an alternative you can, of course, temporarily alter the
%   definition of the command \cs{floatpagekeepfraction} or the values
%   of two counters in mid-document, but remember that they are not
%   looked at when a float is encounteredin the source but when we are
%   at a page break and \LaTeX{} attempts to empty the defer-list
%   which is usually later and unfortunately somewhat asynchonous,
%   i.e., not easy to predict.
%
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex  }
%
%
% \section{The Implementation}
%
%    We start of with package announcement. Requiring a fairly new
%    \LaTeX{} kernel is not absolutely necessary but it will help to
%    ensure that we patch what we think we patch and in the future it
%    means that will can be asured that the rollback functionality of
%    the kernel is available in case will need to support several
%    releases of the package.
%    \begin{macrocode}
%<*package>
\NeedsTeXFormat{LaTeX2e}[2018-04-01]
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesPackage{lessfloatpages}
                [2019-07-29 prerelease  improve float page generation (FMi)]
%    \end{macrocode}
%
% \subsection{Option handling}
%                
%    This release the package has only a single option
%    \texttt{trace}. It enables tracing of the algorithm and is
%    implemented by giving the command \cs{fl@trace} (which is also
%    used by the \pkg{fltrace} package) a suitable definition.
%
%    to cater for the case that the \pkg{fltrace} package is loaded
%    first, we use \cs{providecommand}, so that its definition is not
%    overwritten but used if is already in place. If the package is
%    loaded later everything works fine because it unconditionally
%    defines \cs{fl@trace}.
%
%    \begin{macrocode}
\DeclareOption{trace}
              {\providecommand\fl@trace[1]%
                {{\let\@elt\@empty\typeout{lessfloatpages: #1}}}}
\ProcessOptions
%    \end{macrocode}
%
%
% \subsection{Tracing code}
%                
%  \begin{macro}[internal]{fl@trace}
%    The command \cs{fl@trace} is used to output tracing information.
%    By default the tracing of the algorithm is turned off, so
%    \cs{fl@trace} will simply swallow its argument. But if
%    \pkg{fltrace} is loaded or the option \texttt{trace} is given
%    then the command already has a definition so we don't change it
%    here.
%    \begin{macrocode}
\providecommand\fl@trace[1]{}
%    \end{macrocode}
%  \end{macro}
%
%
% \subsection{User-level interfaces}
%
%    For the most part the packages provides internal code that
%    extends the float algorithm of \LaTeX{}. There are, however, also
%    three new parameters the guide this algorithm, they are defined
%    in this section.
%
%  \begin{macro}[var]{\floatpagekeepfraction}
%    The fraction that the algorithm uses to decide that a given float
%    page is so full that it would be pointless to unravel it for the
%    reasons outlined above. The default is whatever fraction has been
%    chosen as the minim amount of text that need to be on a normal
%    page (i.e., \cs{textfraction}).
%    \begin{macrocode}
\newcommand\floatpagekeepfraction{\textfraction}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}[var]{\c@floatpagenumber}
%    A float page that contains more floats than \ctr{floatpagenumber}
%    will also be unraveled. The default is one more than the standard
%    value for \ctr{topnumber} (which is 3).
%
%    There is a good chsnce that a float page with 4 or less floats is
%    still fairly empty. In that case it might be better to unravel
%    it, even if that means that one of the floats (or perhaps two)
%    can't be placed on the current page but have to move a page
%    further away.  Of course, one could set this parameter to a
%    higher values but then one has to be aware that more floats drift
%    away from their call-out positions.
%    \begin{macrocode}
\newcounter{floatpagenumber}
\setcounter{floatpagenumber}{4}
%    \end{macrocode}
%  \end{macro}

%  \begin{macro}[var]{\c@floatpageunplaced}
%    By default the algorithm will only ever unravel the last float
%    page in a sequence of float pages. However, if the
%    \ctr{floatpageunplaced} counter is set to a positive number, then
%    other float pages come candidates too as long as the number
%    floats waiting to be placed in the defer-list are less or equal
%    to this number.  The default is currently \texttt{0} but perhaps
%    using \texttt{1} or even \texttt{2} might be a better
%    choice. This needs to be evaluated in the field with a suitable
%    number of real test documents.
%    \begin{macrocode}
\newcounter{floatpageunplaced}
\setcounter{floatpageunplaced}{0}
%    \end{macrocode}
%  \end{macro}










%
%  \begin{macro}[internal]{\@tryfcolumn}
%    The main macro we have to patch to extend \LaTeX's algorithm is
%    \cs{@tryfcolumn}. That command is changed when \pkg{fltrace}
%    gets loaded, so we make our definition as late as possible to
%    ensure that it will survive.
%    \begin{macrocode}
\AtBeginDocument{%
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \@tryfcolumn #1{%
  \global \@fcolmadefalse
  \ifx #1\@empty
  \else
    \fl@trace{PAGE: trying to make a float \if@twocolumn column/page\else page\fi}%
    \fl@trace{----- \string #1: #1}%
    \xdef\@trylist{#1}%
    \global \let \@failedlist \@empty
    \begingroup
      \let \@elt \@xtryfc \@trylist
    \endgroup
%    \end{macrocode}
%    Up to this point the definition is the same as in the original
%    algorithm. At this point the  switch \cs{if@fcolmade}  tells us if making a
%    float page was successful and the original algorithm then called
%    \cs{@vtryfc} and remove the used floats from the defer-list.
%
%    In the extended algorithm this is the place where things start to
%    differ as we may not want that float page to actually come into
%    existence.
%    \begin{macrocode}
    \if@fcolmade
%    \end{macrocode}
%    So we want to make some checks to see if it should get
%    unraveled. For this we count the floats that are unplaced. In
%    \cs{@failedlist} we have floats that didn't work as starting
%    floats in earlier loops and in \cs{@flfail} we have those
%    rejected in the current attempt.
%    and record that number in \cs{count@}.
%    \begin{macrocode}
      \count@\z@
      \edef\@tempa{\@failedlist\@flfail}%
      \ifx\@tempa\@empty
        \fl@trace{----- all floats placed on float page(s)}%
      \else
        \fl@trace{----- unplaceable floats: \@tempa}%
        \def\@elt##1{\advance\count@\@ne}%
          \@tempa
        \let\@elt\relax
      \fi
%    \end{macrocode}
%    Now we compare the number of unplaced floats to the number of
%    allowed unplaced floats and if it is too high, we keep the float
%    page.
%    \begin{macrocode}
      \ifnum \count@>\c@floatpageunplaced
        \fl@trace{----- too many unplaced floats for unraveling
	                (> \the\c@floatpageunplaced)}%
%    \end{macrocode}
%
%    Otherwise we do a bit more testing. First we set \cs{if@fcolmade}
%    back to false, i.e., our goal is not to  keep the float page. If
%    during the tests we decide otherwise we set it back to true which
%    then signals that it should stay.
%
%    We also count the floats on the float page and use \cs{count@}
%    for that.
%    \begin{macrocode}
      \else
        \global \@fcolmadefalse
        \count@\z@
%    \end{macrocode}
%    The actually checking is done with
%    \cs{analyse@floats@for@unraveling} and it loops over
%    \cs{@flsucceed}, i.e., the floats for that float page.
%    \begin{macrocode}
        \let\@elt\analyse@floats@for@unraveling
          \@flsucceed
        \let\@elt\relax
%    \end{macrocode}
%    Now we recheck the state of the switch and if it still says
%    \texttt{false} all tests indicated that we don't want the float
%    page.
%    \begin{macrocode}
        \if@fcolmade
        \else
%    \end{macrocode}
%    But we aren't done yet: the float page might be nicely filled in
%    which case it would be a shame to unravel it. During the above
%    loop we also measured the free space on the float page and stored
%    it in \cs{fp@unused@space}. We now compare that to the maximum
%    free space that we consider to be still okay and if there is more
%    we finally do the unraveling.
%    \begin{macrocode}
          \@tempdima\floatpagekeepfraction\@colht
          \ifdim \fp@unused@space >\@tempdima
            \fl@trace{----- current float page unraveled^^J%
                      \@spaces\@spaces\@spaces\space\space\space
                      (free space \fp@unused@space\space > \the\@tempdima)}%
%    \end{macrocode}
%    For this be basically return all floats back to the
%    defer-list. The switch is still \texttt{false} so it doesn't need
%    changing.
%    \begin{macrocode}
            \xdef #1{\@failedlist\@flsucceed\@flfail}%
          \else
%    \end{macrocode}
%    But if we want to keep the float page after all, we have to set
%    the switch back to \texttt{true} so that the rest of the
%    algorithm proceeds correctly.
%    \begin{macrocode}
            \global \@fcolmadetrue
            \fl@trace{----- current float page kept, full enough^^J%
                      \@spaces\@spaces\@spaces\space\space\space
                      (free space \fp@unused@space\space < \the\@tempdima)}%
          \fi
        \fi
      \fi
%    \end{macrocode}
%    The next \cs{else} matches the first \cs{if@fcolmade}, i.e., the
%    case that the algorithm wasn't able to make any float page and if
%    we are tracing the algorithm, we want to tell the user about this.
%    \begin{macrocode}
    \else
      \fl@trace{ --> fail: no float page made}%
    \fi
%    \end{macrocode}
%    
%    At this point we are back in the original algorithm. Now the
%    switch tells the truth about whether or not we want to make a float
%    page and if so we go ahead and produce it.
%    \begin{macrocode}
    \if@fcolmade
        \@vtryfc #1%
    \fi
  \fi
}%
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}[internal]{\@makefcolumn}
%    In contrast to \cs{@tryfcolumn} this macro will always make float
%    pages out of the deferred floats. It is used by \cs{clearpage}
%    when we really need the floats to get out and there is no further
%    text coming up. Thus in that case we should not unravel the float
%    pages. Again we make this change at \verb=\begin{document}= so
%    that we replace any change done by \pkg{fltrace}.
%    \begin{macrocode}
\def\@makefcolumn #1{%
  \begingroup
    \@fpmin -\maxdimen
    \let \@testfp \@gobble
%    \end{macrocode}
%    At this point the original definition called \cs{@tryfcolumn} and
%    the lines aboved ensured that it was always succeeding in making
%    a float page. Since we have changed that command to do unraveling
%    we better not use. Instead we replace it by its original
%    definition (with the addition of two tracing lines.
%    \begin{macrocode}
    \global \@fcolmadefalse
    \ifx #1\@empty
    \else
      \fl@trace{PAGE: trying to make a float \if@twocolumn column/page\else page\fi}%
      \fl@trace{----- \string #1: #1}%
      \xdef\@trylist{#1}%
      \global \let \@failedlist \@empty
      \begingroup
	\let \@elt \@xtryfc \@trylist
      \endgroup
      \if@fcolmade
	\@vtryfc #1%
      \fi
    \fi
  \endgroup
}%
}             % -- END \AtBeginDocument
%    \end{macrocode}
%  \end{macro}







%  \begin{macro}[internal]{\fp@unused@space}
%    
%    \begin{macrocode}
\def\fp@unused@space{}
%    \end{macrocode}
%  \end{macro}




%  \begin{macro}{}
%    For fltrace
%    \begin{macrocode}
\def\@xtryfc #1{%
  \fl@trace{ starting with \string#1}%
  \@next\reserved@a\@trylist{}{}%
  \@currtype \count #1%
  \divide\@currtype\@xxxii
  \multiply\@currtype\@xxxii
  \@bitor \@currtype \@failedlist
  \@testfp #1%
  \@testwrongwidth #1%
  \ifdim \ht #1>\@colht
     \@testtrue
  \fi
  \if@test
    \@cons\@failedlist #1%
    \fl@trace{ --> fail}%
  \else
    \@ytryfc #1%
  \fi
}%
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}[internal]{\@ytryfc}
%    
%    \begin{macrocode}
\def\@ytryfc #1{%
  \begingroup
    \gdef\@flsucceed{\@elt #1}%
    \global\let\@flfail\@empty
    \@tempdima\ht #1%
    \let\@elt\@ztryfc
    \@trylist
    \ifdim \@tempdima >\@fpmin
      \global\@fcolmadetrue
%    \end{macrocode}
%    
%    \begin{macrocode}
      \@tempdimb\@colht
      \advance\@tempdimb-\@tempdima
      \xdef\fp@unused@space{\the\@tempdimb}%
%    \end{macrocode}
%    
%    \begin{macrocode}
    \else
      \@cons\@failedlist #1%
      \fl@trace{ --> fail}%
    \fi
  \endgroup
  \if@fcolmade
    \let\@elt\@gobble
    \fl@trace{ --> success: \@flsucceed}%
  \fi}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}[internal]{\analyse@floats@for@unraveling}
%    
%    \begin{macrocode}
\def\analyse@floats@for@unraveling#1{%
  \advance\count@\@ne
  \ifnum \count@ >\c@floatpagenumber
    \global \@fcolmadetrue
    \let\@elt\@gobble
    \fl@trace{----- current float page kept, contains many floats^^J%
                      \@spaces\@spaces\@spaces\space\space\space
                      (at least \the\count@\space > \the\c@floatpagenumber)}%
  \else
    \@tempcntb\count#1%
    \divide\@tempcntb 8\relax
    \multiply\@tempcntb 8\relax
%
    \ifnum \count#1=\@tempcntb
      \global \@fcolmadetrue
      \let\@elt\@gobble
    \fl@trace{----- current float page kept, contains a [p] float}%
    \fi
  \fi
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% \Finale
%


